<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Deng 的梦呓">
<meta property="og:url" content="http://wudeng.github.io/index.html">
<meta property="og:site_name" content="Deng 的梦呓">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Deng 的梦呓">
  <link rel="canonical" href="http://wudeng.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Deng 的梦呓</title>
  <meta name="generator" content="Hexo 3.9.0">
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?356ed3e5db3bc7eda8ce3e7833731107";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Deng 的梦呓</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2018/04/13/wordfilter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/04/13/wordfilter/" class="post-title-link" itemprop="url">敏感词过滤</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-04-13 00:00:00" itemprop="dateCreated datePublished" datetime="2018-04-13T00:00:00+08:00">2018-04-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><p>Deterministic Finite Automation 确定有穷自动机。<br>我理解其实就是一个简单的Trie树，节点带output，对于结束的节点，把对应的字符串写在output里面。<br>对于字符串中的每个字符，查找Trie树中能否走到有单词结束标记的节点。匹配失败的话需要回退。</p>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>Aho-Corasick算法，在Trie树的基础上加入了fail指针。Unix工具fgrep的底层实现就是用的AC自动机。</p>
<p>每条边代表一个字符。同一个节点出来的边代表的字符各不相同。每个节点代表一个状态。<br>状态的迁移由三个函数决定：goto，failure，output。而failure函数是AC自动机最难也是最关键的一环。</p>
<p>假设有字符串ABCDE匹配到模式ABC，结果D没匹配上。这说明模式ABCD是不可能的了。这时候按照传统的算法，<br>应该从字符串中A的下一个字符也就是B开始重新从根节点进行匹配。但是我们已经知道了B后面是CD，<br>最好的情况就是模式中刚好有BCD开头的这个模式，我们一路匹配到BCD。那么如果我们能直接从ABC的C跳到BCD这个D节点就好了。<br>failure指针就是干这个的。如果BCD模式也没有，那么我们就退而求其次看看有没有CD，没有CD，那就直接看D，如果都没有，<br>那D也不用看了，直接从根节点匹配E吧。失败指针构造就是这么个递归的查找过程，这其中包含了动态规划的思想。<br>实际构造失败指针的时候，父节点的失败指针是一层层已经构造好了的，所以其实就是一个自底向上的动态规划过程。<br>简单的说失败指针就是用当前模式的后缀去匹配其他模式的前缀。失败指针代表的字符跟节点本身要么是一样的，<br>要么是空（也就是根节点）。</p>
<p>node: children, output, fail point</p>
<ul>
<li>build a trie tree with output, when finish, every node only has one output</li>
<li>build fail point<ul>
<li>root node’s children fail to the root, add children to a fifo queue</li>
<li>pop one node out of queue, build fail point for children of that node<ul>
<li>for every child, find the closest children, starting from the fail node,<br>  check if it has the character of the child node ?<ul>
<li>if true, then point to that node, add the failed node’s output to the current node</li>
<li>if false, fail to the root</li>
</ul>
</li>
<li>node in queue, already build fail node</li>
</ul>
</li>
</ul>
</li>
<li>match<ul>
<li>if fail, go to the fail node, and continue the match</li>
</ul>
</li>
</ul>
<p>构造失败指针这部分比较麻烦一点。思路是从父节点的fail node开始，递归的往上找fail node，<br>看fail node的子节点是否有包含当前节点相同字符的节点，如果有，将该子节点设为当前节点的<br>fail节点，并且将fail节点的output也加到当前节点的output列表中。如果没有，一路递归到根节点。<br>构造的过程是一层层往下的，所以处理低层的节点的时候高层的节点都已经处理好了。<br>其实就是一个宽度优先的遍历。</p>
<p>匹配的时候从根节点开始往下找，匹配失败就递归的往上找失败节点。匹配失败目标字符串不需要回退。<br>类似KMP的匹配，所以效率很高。</p>
<h2 id="Erlang实现AC自动机"><a href="#Erlang实现AC自动机" class="headerlink" title="Erlang实现AC自动机"></a>Erlang实现AC自动机</h2><p>在<a href="https://github.com/josemic/ahocorasick.git" target="_blank" rel="noopener">这里</a>找到了一个erlang版本的ac自动机，<br>可惜是一个不完整的版本，因为失败指针没有正确的构建，所以有些情况下不能正确匹配。<br>比如：词库中有”BC”、”ABCD”这两个违禁词，但是尝试匹配”ABC”的时候发现匹配不到。<br>而正常的AC自动机是能够匹配上的。这是因为这里的自动机少了第二步，构造失败指针，<br>这样失败指针指向的节点的output也不会加入到当前节点。所以出现上面的问题。</p>
<p>自己撸了一个Erlang版本的AC自动机，用了map结构，代码很精简，一百来行，基本比较完整实现了<br>功能，包括失败指针的构造，<a href="https://github.com/wudeng/aho-corasick.git" target="_blank" rel="noopener">代码</a>放在github上了。<br>对比了一下之前用re正则模块一个个匹配的方法，AC的性能提升超过1000倍。</p>
<h2 id="binary模块"><a href="#binary模块" class="headerlink" title="binary模块"></a>binary模块</h2><blockquote>
<p>众里寻他千百度，蓦然回首，那人却在灯火阑珊处。</p>
</blockquote>
<p>AC自动机的实现有各种语言的版本，唯独Erlang的非常少。<br>找到一个纯Erlang实现的还只是实现了一部分。最关键的fail函数没有实现。导致匹配的时候<br>会出现上面的问题。</p>
<p>其实Erlang已经为我们实现了一个AC自动机，就在binary模块中。通过这个模块<br>的源码<code>erl_bif_binary.c</code>可以看到这样一段注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The native implementation functions for the module binary.</span></span><br><span class="line"><span class="comment"> * Searching is implemented using either Boyer-Moore or Aho-Corasick</span></span><br><span class="line"><span class="comment"> * depending on number of searchstrings (BM if one, AC if more than one).</span></span><br><span class="line"><span class="comment"> * Native implementation is mostly for efficiency, nothing</span></span><br><span class="line"><span class="comment"> * (except binary:referenced_byte_size) really *needs* to be implemented</span></span><br><span class="line"><span class="comment"> * in native code.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>可以看出binary的搜索是基于BM和AC算法来实现的。如果模式只有一个就是BM，如果有多个就是AC。因此要实现替换功能，<br>只需要直接调用<code>binary:replace(Subject, Pattern, Replacement, Options)</code>方法即可。<br>另外binary还提供了一个<code>binary:compie_pattern(Pattern)</code>函数，这样可以把模式存储下来，<br>后续的匹配直接使用即可。不过这里每个节点其实不是一个有效的utf8字符，而只是一个字节。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cp = binary:compile_pattern(Patterns),</span><br><span class="line">io:format(<span class="string">"~ts"</span>,[binary:replace(Text,Cp,&lt;&lt;<span class="string">"*"</span>&gt;&gt;,[global])]).</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://blog.csdn.net/liangrui1988/article/details/44873331" target="_blank" rel="noopener">https://blog.csdn.net/liangrui1988/article/details/44873331</a> Java实现</li>
<li><a href="https://github.com/importcjj/sensitive" target="_blank" rel="noopener">https://github.com/importcjj/sensitive</a> 就是一个简单Trie树，DFA</li>
<li><a href="https://github.com/gonet2/wordfilter" target="_blank" rel="noopener">https://github.com/gonet2/wordfilter</a> go</li>
<li><a href="https://github.com/observerss/textfilter" target="_blank" rel="noopener">https://github.com/observerss/textfilter</a> python</li>
<li><a href="https://github.com/toolgood/ToolGood.Words" target="_blank" rel="noopener">https://github.com/toolgood/ToolGood.Words</a></li>
<li><a href="http://www.hankcs.com/program/algorithm/aho-corasick-double-array-trie.html" target="_blank" rel="noopener">http://www.hankcs.com/program/algorithm/aho-corasick-double-array-trie.html</a></li>
<li><a href="https://github.com/anknown/ahocorasick" target="_blank" rel="noopener">https://github.com/anknown/ahocorasick</a> go ac</li>
<li><a href="http://www.cs.uku.fi/~kilpelai/BSA05/lectures/slides04.pdf" target="_blank" rel="noopener">http://www.cs.uku.fi/~kilpelai/BSA05/lectures/slides04.pdf</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2018/03/29/erlang-time/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/03/29/erlang-time/" class="post-title-link" itemprop="url">Erlang时间系统</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-03-29 00:00:00" itemprop="dateCreated datePublished" datetime="2018-03-29T00:00:00+08:00">2018-03-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Erlang系统中有两套时间系统。一个是操作系统时间，一个是虚拟机时间。我们知道，操作系统时间是非常不可靠的，<br>它依靠ntp跟网络上服服务器同步，也有可能被人为修改。如果依赖操作系统时间，程序可能出现异常的行为。<br>比如游戏中一个设定是每天0点进行结算，如果结算完一次这时操作系统时间调整回去了，结果又会结算一次。<br>因此ERTS在操作系统时间的基础之上引入了虚拟机时间。</p>
<p>在Erlang/OTP 18(ERTS 7.0)之前，获取时间的接口主要是两个：</p>
<ul>
<li>erlang:now()返回虚拟机时间</li>
<li>os:timestamp()返回操作系统时间。</li>
</ul>
<p>erlang:now()存在性能问题，因此很多软件被迫使用os:timestamp()来代替。但是操作系统时间又存在时间回退的问题。</p>
<p>18之前，操作系统时间变化时，只能通过时间纠正来慢慢系统时间对齐，这个调整的过程可能是非常漫长的。<br>1分钟的差异需要100分钟才能调整完。这段时间内的时间间隔，定时器都会受到影响，大约存在1%的偏差。</p>
<p>从OTP 18以后，把虚拟机时间分为了两个部分，time_offset和monotonic_time。前者用来跟操作系统对齐，<br>后者用来实现稳定的时间频率。同时引入了三种time warp mode。time correction加上time warp mode，<br>更好的处理系统时间的跳变。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>UT1：世界时</li>
<li>UTC：Coordinated Universal Time，协调世界时，对秒的定义跟UT1有差异，包含闰秒。UTC的一天可能为86399, 86400, 86401秒。</li>
<li>POSIX Time(aka Unix/Epoch time): Time since EPOCH (UTC 1970-01-01 00:00:00)，POSIX Time的一天刚好为86400秒。奇怪的是EPOCH被定义为UTC时间。</li>
<li><code>OS System Time</code>：操作系统视角的POSIX time。存在时间跳跃。</li>
<li><code>Erlang System Time</code>: Erlang运行时视角的POSIX time。跟操作系统时间可能有偏差。</li>
<li>Erlang monotonic time: events, timers, time interval, 单调，但是不严格单调递增。</li>
<li>Time offset: 通过时间偏移来同步操作系统时间，无需修改单调时间的频率。</li>
</ul>
<p>时间单位：每秒多少个单位:</p>
<ul>
<li>second，1</li>
<li>millisecond，1000</li>
<li>microsecond，1000000</li>
<li>nanosecond，1000000000</li>
<li>native，Erlang runtime system使用的单位，不同的操作系统会不一样。我的电脑里面，Windows下为1024000，CentOS下为1000000000。</li>
</ul>
<p>时间单位之间的转化可以通过函数实现：<br><code>erlang:convert_time_unit(Time, FromUnit, ToUnit)</code>。</p>
<h2 id="Time-Warp-Mode"><a href="#Time-Warp-Mode" class="headerlink" title="Time Warp Mode"></a>Time Warp Mode</h2><ul>
<li><code>no_time_warp</code> 默认方式，系统启动的时候就决定了time offset，以后也不会改变。<br>跟之前的系统兼容。因为offset不会变。所以只能通过调整monotonic_time的频率来接近系统时间。<br>这会造成monotonic_time的时间频率存在1%的误差。</li>
<li><code>multi_time_warp</code> 直接改变offset来同步时间，monotonic_time保持相对的稳定，当系统时间发生跳变的时候，<br>可以通过<code>erlang:monitor(time_offset, clock_service)</code>来获得通知。</li>
<li><code>single_time_warp</code> 主要用于嵌入式系统。</li>
<li>可以通过虚拟机标记<code>+C no_time_mode | multi_time_warp | single_time_warp</code>来配置。</li>
</ul>
<h2 id="Time-Correction"><a href="#Time-Correction" class="headerlink" title="Time Correction"></a>Time Correction</h2><ul>
<li>可以通过虚拟机标记来配置是否开启：<code>+c true | false</code></li>
<li>如果设置为true，Erlang通过加速和减速来跟操作系统时间同步。幅度最大是1%，也就是说，VM经历1秒实际上可能是0.99秒或者1.01秒。<br>当系统时间改变了1分钟，erlang会花100分钟来慢慢校正，并最终与系统时间同步。</li>
<li>如果设置为false，当操作系统时间落后时，虚拟机时间会停滞。直到操作系统时间追上来为止。这意味着重复调用erlang:monotonic_time()会返回相同的值。<br>当操作系统时间领先时，monotonic_time前跳。</li>
</ul>
<p>可以通过函数<code>erlang:system_info(time_correction).</code>来查看时间纠正是否开启。<br>关闭这个选项不会获得任何好处，而且当发生时间跳变时，Erlang monotonic time可能向前跳或者停止。<br>所以这个选项一般都是打开的。</p>
<p>一般常用到的配置：</p>
<ul>
<li><code>+c true +C no_time_warp</code> offset保持不变，mono改变%1来追赶OS时间。跟18之前表现是一样的。</li>
<li><code>+c true +C multi_time_warp</code> offset随着OS时间而变化，mono保持相对稳定的频率。</li>
</ul>
<h2 id="OS-System-Time"><a href="#OS-System-Time" class="headerlink" title="OS System Time"></a>OS System Time</h2><p>操作系统时间不是单调递增的。系统时间随时可以修改。比如我取了一个操作系统时间t1，<br>然后将系统时间改为1天前，再取一个系统时间t2，t2-t1的出来是个负值。</p>
<p>新API主要提供这三个接口来获取操作系统时间。</p>
<ul>
<li><code>os:system_time()</code> 返回native时间单位的操作系统时间<code>os system time</code></li>
<li><code>os:system_time(Unit)</code> 将操作系统时间转化为Unit时间单位。等价于 <code>erlang:convert_time_unit(os:system_time(), native, Unit)</code>。</li>
<li><code>os:timestamp() -&gt; {MegaSecs, Secs, MicroSecs}</code><ul>
<li><code>calendar:now_to_universal_time/1</code></li>
<li><code>calendar:now_to_local_time/1</code></li>
</ul>
</li>
</ul>
<p>比如计算年月日：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">format_utc_timestamp</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    TS = &#123;_,_,Micro&#125; = os:timestamp(),</span><br><span class="line">    &#123; &#123;Year,Month,Day&#125;,&#123;Hour,Minute,Second&#125; &#125; = calendar:now_to_universal_time(TS),</span><br><span class="line">    Mstr = element(Month,&#123;<span class="string">"Jan"</span>,<span class="string">"Feb"</span>,<span class="string">"Mar"</span>,<span class="string">"Apr"</span>,<span class="string">"May"</span>,<span class="string">"Jun"</span>,<span class="string">"Jul"</span>,<span class="string">"Aug"</span>,<span class="string">"Sep"</span>,<span class="string">"Oct"</span>,<span class="string">"Nov"</span>,<span class="string">"Dec"</span>&#125;),</span><br><span class="line">    io_lib:format(<span class="string">"~2w ~s ~4w ~2w:~2..0w:~2..0w.~6..0w"</span>,[Day,Mstr,Year,Hour,Minute,Second,Micro]).</span><br></pre></td></tr></table></figure>

<p>另外，erlang:date()，erlang:localtime()等函数都是通过操作系统时间算出来的。<br>通过下面的接口可以看到操作系统接口调用的底层接口，比如Windows下面是这样的：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; erlang:system_info(os_system_time_source).</span><br><span class="line">[&#123;function,'GetSystemTime'&#125;,</span><br><span class="line"> &#123;resolution,<span class="number">100</span>&#125;,</span><br><span class="line"> &#123;parallel,yes&#125;,</span><br><span class="line"> &#123;time,<span class="number">1558773547665408</span>&#125;]</span><br><span class="line"></span><br><span class="line">&gt; erlang:system_info(os_monotonic_time_source).</span><br><span class="line">[&#123;function,'GetTickCount64'&#125;,</span><br><span class="line"> &#123;resolution,<span class="number">100</span>&#125;,</span><br><span class="line"> &#123;extended,no&#125;,</span><br><span class="line"> &#123;parallel,yes&#125;,</span><br><span class="line"> &#123;time,<span class="number">1191373658112</span>&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="Erlang-System-Time"><a href="#Erlang-System-Time" class="headerlink" title="Erlang System Time"></a>Erlang System Time</h2><p>正是因为操作系统时间如此不可靠，我们需要一个经过纠正的虚拟机时间。<br>这个纠正的虚拟机时间具有以下特性：</p>
<ul>
<li>Never jumps backwards or forwards</li>
<li>Never differs more than 1% in speed from OS Monotonic time</li>
<li>Attemps to be as close as possible to OS system time</li>
</ul>
<p>jumping from 1970 to 2015 will take 4500 years to recover, which means all relative time will happen 1% faster for many years.</p>
<p>新API提供以下接口用于获取虚拟机时间：</p>
<ul>
<li>erlang:system_time() 返回native时间单位的虚拟机时间<code>erlang system time</code>，虚拟机时间由两部分构成：time_offset和monotonic_time。<br>erlang:system_time() 等价于 erlang:monotonic_time() + erlang:time_offset()</li>
<li>erlang:system_time(Unit) 将erlang系统时间转化为Unit时间单位。等价于<code>erlang:convert_time_unit(erlang:system_time(), native, Unit)</code></li>
<li>erlang:monotonic_time() 虚拟机内部的时间引擎。定时器、receive after定时器、BIF定时器、timer模块定时器都是由这个时间触发。</li>
<li>erlang:time_offset()</li>
<li>erlang:timestamp() -&gt; {MegaSecs, Secs, MicroSecs} <code>Erlang system time</code>，这个函数的存在只是为了兼容现有的代码的时间格式。<br><code>Erlang system time</code>可以通过上面的函数erlang:system_time/1更加高效的获取。这个函数等价于：</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">timestamp</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    ErlangSystemTime = erlang:system_time(microsecond),</span><br><span class="line">    MegaSecs = ErlangSystemTime <span class="keyword">div</span> <span class="number">1000000000000</span>,</span><br><span class="line">    Secs = ErlangSystemTime <span class="keyword">div</span> <span class="number">1000000</span> - MegaSecs*<span class="number">1000000</span>,</span><br><span class="line">    MicroSecs = ErlangSystemTime <span class="keyword">rem</span> <span class="number">1000000</span>,</span><br><span class="line">    &#123;MegaSecs, Secs, MicroSecs&#125;.</span><br></pre></td></tr></table></figure>

<h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><p>一个总的原则就是：不要使用<code>erlang:now/0</code>。根据不同的目的，选择不同的接口。</p>
<h3 id="获取系统时间"><a href="#获取系统时间" class="headerlink" title="获取系统时间"></a>获取系统时间</h3><p>使用erlang:system_time/1获取系统时间。如果需要erlang:now/0返回的数据格式，可以用erlang:timestamp/0。</p>
<h3 id="测量时间差"><a href="#测量时间差" class="headerlink" title="测量时间差"></a>测量时间差</h3><p>使用erlang:monotonic_time/0之差来测量时间，结果是native时间单位，可以用erlang:convert_time_unit/3来转化为其他时间单位。<br>也可以直接使用erlang:monotonic_time/1之差来测量时间，不过这种方式会损失一定的精度。</p>
<h3 id="事件的顺序"><a href="#事件的顺序" class="headerlink" title="事件的顺序"></a>事件的顺序</h3><p>erlang:unique_integer([monotonic]). 严格单调递增。</p>
<h3 id="唯一名字"><a href="#唯一名字" class="headerlink" title="唯一名字"></a>唯一名字</h3><ul>
<li>erlang:unique_integer/0</li>
<li>erlang:unique_integer([positive])</li>
</ul>
<h3 id="随机数种子"><a href="#随机数种子" class="headerlink" title="随机数种子"></a>随机数种子</h3><ul>
<li>erlang:monotonic_time()</li>
<li>erlang:time_offset()</li>
<li>erlang:unique_integer()</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://learnyousomeerlang.com/time" target="_blank" rel="noopener">http://learnyousomeerlang.com/time</a></li>
<li>erts-9.2/doc/html/time_correction.html</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2018/02/27/docker-on-windows7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/27/docker-on-windows7/" class="post-title-link" itemprop="url">docker on windows7</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-02-27 00:00:00" itemprop="dateCreated datePublished" datetime="2018-02-27T00:00:00+08:00">2018-02-27</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>windows 7以前的系统需要通过虚拟机软件运行boot2docker来支持docker,<br>一般使用VirtualBox来运行boot2docker。boot2docker是一个支持docker的linux环境。</p>
<h2 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h2><p>windows上安装虚拟机需要先开启cpu的虚拟化支持，否则会有报错：</p>
<blockquote>
<p>Error in driver during machine creation: This computer doesn’t have VT-X/AMD-v enabled.<br>Enabling it in the BIOS is mandatory</p>
</blockquote>
<p>这是因为电脑虚拟化技术处于被禁用状态，这时就要启动BIOS的虚拟化设置，开启CPU虚拟化支持。<br>在BIOS中找到CPU的Intel Virtualization Technology选项，选择Enable，保存退出重启即可。</p>
<h2 id="docker-machine"><a href="#docker-machine" class="headerlink" title="docker-machine"></a>docker-machine</h2><p>docker-machine是虚拟机管理程序。我们可以通过它来登陆boot2docker，查看各种虚拟机相关的信息如ip，环境变量等。<br>在docker客户端输入docker-machine help就能看到帮助。</p>
<p>docker-machine 支持的命令主要有：</p>
<ul>
<li>active 打印运行中的虚拟机名称，默认虚拟机为default</li>
<li>config 打印连接参数</li>
<li>create 新建虚拟机</li>
<li>env</li>
<li>inspect</li>
<li>ssh 连接虚拟机，docker-machine ssh default 就能连接到默认的虚拟机中。</li>
<li>ls</li>
<li>ip 查看boot2docker虚拟机的ip地址，通常是<code>192.168.99.100</code>。</li>
</ul>
<p>虚拟机的默认账号是docker, 密码是tcuser。docker用户是sudoers, 直接执行sudo -i就能切换为root账号。</p>
<h2 id="文件夹挂载"><a href="#文件夹挂载" class="headerlink" title="文件夹挂载"></a>文件夹挂载</h2><p>跟linux系统不一样，windows下的宿主系统并不是windows本身，而是运行在虚拟机中的boot2docker，<br>所以在windows下挂载volumn的时候，不能直接把windows下的目录挂载到容器中。</p>
<p>要实现挂载，首先要通过虚拟机系统把windows下的文件夹共享到虚拟机中，默认的虚拟机已经共享了一个文件夹：<code>c:\Users</code>，对应的虚拟机中的目录是：<code>/c/Users</code>。<br>所以一般情况下我们是可以把<code>/c/Users</code>目录下的文件夹挂载到容器中去。<br>所以<code>docker run --rm -it -v /c/Users:/c/ erlang:19.3.3 ls /c/</code>这条命令能够列出<code>C:\Users</code>下面的文件。</p>
<p>但是如果需要支持其他目录，首先要通过VirtualBox把文件夹共享到虚拟机中，<br>然后才能挂载到容器中。而且使用的时候使用的宿主目录不是windows下的目录，而是虚拟机中的挂载目录。</p>
<p>直接用打开VirtualBox，能看到一个名为default的虚拟机，这个虚拟机就是docker的宿主机，<br>在这个虚拟机中创建一个共享文件夹，比如把<code>D:\</code>挂载到<code>/d</code>目录下。<br>通过<code>docker-machine restart</code>重启虚拟机。</p>
<p><code>docker run --rm -it -v /d/projects:/apps -w /apps erlang:19.3.3 ./rebar3 as prod tar</code></p>
<p>这条命令会把windows下的<code>D:\projects</code>目录通过宿主机的<code>/d/projects</code>挂载到容器的<code>/apps</code>目录下。并且把<code>/apps</code>作为容器的工作目录。<br>这样就能实现通过docker来实现跨平台的编译。顺便说一句，如果只需要支持特定平台的编译，用Jenkins实现目标环境的编译更加方便。</p>
<h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>容器的端口也是映射到宿主机中而不是windows中。这一点也要注意，windows中访问端口的时候要使用宿主机的ip，而不是自身的ip。<br>宿主机的ip可以通过<code>docker-machine ip</code>来查看。一般是<code>192.168.99.100</code>.</p>
<h3 id="配置加速器"><a href="#配置加速器" class="headerlink" title="配置加速器"></a>配置加速器</h3><p>由于DockerHub默认使用的国外的镜像地址，在国内使用的速度感人，需要配置国内的加速。<br>我本人使用的是<a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">DaoCloud</a>的加速服务，注册账号以后会分配一个私有的加速地址。<br>也可以直接用<a href="https://www.docker-cn.com/registry-mirror。" target="_blank" rel="noopener">https://www.docker-cn.com/registry-mirror。</a><br>修改方法如下：<br>首先通过<code>docker-machine ssh &lt;machine-name&gt;</code>登录虚拟机，默认名字为default.<br>然后修改/var/lib/boot2docker/profile文件，<br><code>sudo vi /var/lib/boot2docker/profile</code><br>将–registry-mirror=<your accelerate address>添加到EXTRA_ARGS中<br>最后sudo /etc/init.d/docker restart重启Docker服务就可以了。</your></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2018/01/15/kcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/01/15/kcp/" class="post-title-link" itemprop="url">kcp源码解析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-01-15 00:00:00" itemprop="dateCreated datePublished" datetime="2018-01-15T00:00:00+08:00">2018-01-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">kcp</a>是一个实现了类似tcp的重传、流控、拥塞控制等机制的传输协议，它没有指定传输协议，但是一般情况下都会用udp来传输，<br>相当于用udp实现的tcp协议。它在不稳定的网络环境中采用更激进的方法来获得比tcp更快的传输速度，代价就是会消耗更多的流量。<br>跟tcp一样，kcp采用滑动窗口机制来实现流控，通过重传机制保证了可靠性，通过慢启动，拥塞避免，快速重传和快速恢复来实现拥塞控制。</p>
<p>kcp支持两种模式：流模式和消息模式。</p>
<p><img src="kcp_stream_mode.png" alt></p>
<p>流模式具有更高网络利用率，更大的传输速度，但是解析数据相对更复杂。</p>
<p><img src="kcp_message_mode.png" alt></p>
<p>消息模式具有更小的网络利用率，更小的传输速度，但解析数据更简单。</p>
<h2 id="相关变量"><a href="#相关变量" class="headerlink" title="相关变量"></a>相关变量</h2><table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>rcv_wnd</td>
<td>receive window</td>
<td>接收窗口大小</td>
</tr>
<tr>
<td>rmt_wnd</td>
<td>remote window</td>
<td>远端可接收窗口。发送端发送数据的时候带上，接收端接收到数据时更新</td>
</tr>
<tr>
<td>snd_wnd</td>
<td>send window</td>
<td>发送窗口大小</td>
</tr>
<tr>
<td>cwnd</td>
<td>congestion window</td>
<td>拥塞窗口大小</td>
</tr>
<tr>
<td>rcv_buf</td>
<td>receive buffer</td>
<td>接收缓冲区，缓冲底层接收的数据，组装连续以后拷贝到接收队列</td>
</tr>
<tr>
<td>rcv_queue</td>
<td>receive queue</td>
<td>接收队列，接收的连续数据包，上层应用可以直接使用，不能超过接收窗口大小</td>
</tr>
<tr>
<td>snd_queue</td>
<td>send queue</td>
<td>发送队列，上层应用数据分片后加入发送队列</td>
</tr>
<tr>
<td>snd_buf</td>
<td>send buffer</td>
<td>发送缓冲区，已发送尚未确认的包</td>
</tr>
<tr>
<td>buffer</td>
<td></td>
<td>调用output发送的数据</td>
</tr>
<tr>
<td>probe</td>
<td></td>
<td>ICKP_CMD_WASK  IKCP_CMD_WINS</td>
</tr>
<tr>
<td>acklist</td>
<td>sn,ts</td>
<td>待发送的ack列表</td>
</tr>
<tr>
<td>fastresend</td>
<td></td>
<td>快速重传门限，无须等待超时，如果n没收到ack但是收到了n+1,n+2,…n+fastresend那么立即重传n</td>
</tr>
<tr>
<td>ssthresh</td>
<td>slow start thresh</td>
<td>拥塞窗口阈值</td>
</tr>
<tr>
<td>incr</td>
<td></td>
<td>可发送的最大数据量</td>
</tr>
<tr>
<td>stream</td>
<td>stream mode</td>
<td>是否使用流模式</td>
</tr>
</tbody></table>
<h2 id="RTO计算（Retransmission-timeout）"><a href="#RTO计算（Retransmission-timeout）" class="headerlink" title="RTO计算（Retransmission timeout）"></a>RTO计算（Retransmission timeout）</h2><p>kcp的重传超时计算方法参考了tcp的实现<a href="https://tools.ietf.org/rfc/rfc6298.txt" target="_blank" rel="noopener">Computing TCP’s Retransmission Timer</a>，不过在参数设置上更加激进。<br>计算过程主要维护两个变量：</p>
<ul>
<li>SRTT: smoothed round-trip time</li>
<li>RTTVAR: round-trip time variation</li>
</ul>
<p>接收端收到确认包以后根据rtt更新这两个变量，并重新计算rto值。报文超时以后tcp的rto会翻倍，<br>kcp中声称采用的是1.5倍，然而代码中实际上是线性增加，不知道是作者有意为之还是实现bug。</p>
<h2 id="Segment头部"><a href="#Segment头部" class="headerlink" title="Segment头部"></a>Segment头部</h2><table>
<thead>
<tr>
<th>含义</th>
<th>会话id</th>
<th>包类型</th>
<th>是否分片</th>
<th>发送端接收窗口</th>
<th>时间戳</th>
<th>包序列号</th>
<th>未确认包序号</th>
<th>数据长度</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>字节数</td>
<td>4</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>len</td>
</tr>
<tr>
<td>字段名</td>
<td>conv</td>
<td>cmd</td>
<td>frg</td>
<td>wnd</td>
<td>ts</td>
<td>sn</td>
<td>una</td>
<td>len</td>
<td>data</td>
</tr>
<tr>
<td>全名</td>
<td>conversation id</td>
<td>command</td>
<td>fragment</td>
<td>window</td>
<td>timestamp</td>
<td>segment number</td>
<td>unacknowledge</td>
<td>length</td>
<td>data</td>
</tr>
</tbody></table>
<p>报文字段含义：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>conv</td>
<td>通信双方需要保证相同的会话id</td>
</tr>
<tr>
<td>cmd</td>
<td>ICKP_CMD_PUSH/IKCP_CMD_ACK/IKCP_CMD_WASK/ICKP_CMD_WINS</td>
</tr>
<tr>
<td>frg</td>
<td>分片ID，从大到小，0表示最后一个分片</td>
</tr>
<tr>
<td>wnd</td>
<td>剩余接收窗口大小（接收窗口大小 - 接收队列大小）</td>
</tr>
<tr>
<td>ts</td>
<td>message发送时刻的时间戳</td>
</tr>
<tr>
<td>sn</td>
<td>分片segment序号</td>
</tr>
<tr>
<td>una</td>
<td>待接收消息序号（接收滑动窗口左端）</td>
</tr>
<tr>
<td>len</td>
<td>数据长度</td>
</tr>
<tr>
<td>data</td>
<td>数据</td>
</tr>
<tr>
<td>fastack</td>
<td>收到ack时计算的该分片被跳过的累积次数</td>
</tr>
<tr>
<td>xmit</td>
<td>分片发送的次数，每发送一次加1,超出dead_link，说明目标不可达</td>
</tr>
<tr>
<td>resendts</td>
<td>下一次超时重传的时间戳</td>
</tr>
<tr>
<td>rto</td>
<td>该分片的超时重传等待时间</td>
</tr>
</tbody></table>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="kcp与底层交互"><a href="#kcp与底层交互" class="headerlink" title="kcp与底层交互"></a>kcp与底层交互</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ikcp_output</span><span class="params">(ikcpb *kcp, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ickp_input</span><span class="params">(ikcpcb *kcp, <span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">long</span> size)</span></span></span><br></pre></td></tr></table></figure>

<p>这两个结构是kcp与底层网络交互的接口。一般底层网络指的是UDP。<br>output将kcp打包的数据发往目的地址，而input是底层网卡收到udp数据以后喂给kcp层。</p>
<p>底层收到数据报文后调用input，将数据丢给kcp。</p>
<p>上层通过recv获得处理后的数据，循环从data中取出kcp包。直到剩下的长度小于包头长度退出循环。</p>
<p>input传入的数据包含kcp包头，kcp拿到以后会尝试去掉kcp包头，组合成一个完整的数据包：</p>
<ul>
<li>长度小于包头长度24，退出循环。</li>
<li>构造包头，分别检查会话id，数据长度，包体类型。</li>
<li>设置远程剩余接收窗口大小。</li>
<li>将对方已经确认收到的包从发送缓存snd_buf中删除，相当于发送窗口右移。</li>
<li>计算本地真实snd_una，也就是下一个等待确认的发送包。<ul>
<li>如果还有未确认的包，为发送窗口左端包序列号</li>
<li>如果没有未确认包，即发送窗口为空，则为下一个发送包snd_nxt</li>
</ul>
</li>
<li>根据包的不同类型分别处理<ul>
<li>ACK包：<ul>
<li>计算rtt，更新rto，更新算法参考rfc6298</li>
<li>从发送窗口中删除对应的包，并更新此包之前未确认包的fastack信息</li>
</ul>
</li>
<li>PUSH数据包：<ul>
<li>判断收到的包的sn是不是位于区间：[rcv_nxt, rcv_nxt+rcv_wnd), 是则继续，否则丢弃</li>
<li>在接收窗口内，将其加入acklist，下一次flush的时候确认</li>
<li>构造一个kcp包，判断是否重复，如果不是重复包，插入接收缓存rcv_buf中对应位置</li>
<li>将rcv_buf中的已经收到的连续包移到接收队列rcv_queue中，供上层应用读取，并从rcv_buf中移除</li>
</ul>
</li>
<li>WASK包：<ul>
<li>设置probe的TELL标记，flush的时候推送</li>
</ul>
</li>
<li>WINS包：<ul>
<li>无须处理，因为之前已经设置了对方的剩余接收窗口大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所有包处理完毕以后，根据对方确认包的信息，更新拥塞窗口大小。</p>
<ul>
<li>如果拥塞窗口小于对方剩余接收窗口，则需要更新</li>
<li>如果拥塞窗口尚未达到ssthresh（慢启动门限），cwnd++</li>
<li>如果大于ssthresh,</li>
</ul>
<h3 id="kcp与应用层交互"><a href="#kcp与应用层交互" class="headerlink" title="kcp与应用层交互"></a>kcp与应用层交互</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ikcp_recv</span><span class="params">(ikcpcb *kcp, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>将接收队列中的消息传递给上层应用，因为消息会被拆分成kcp包，所以消息长度需小于接收队列长度*报文长度。</li>
<li>将接收缓冲中的连续报文拷贝到接收队列。</li>
<li>如果接收队列从满到不满，推送窗口通知消息给发送端，通知有接收窗口，可以继续发送新的报文。</li>
<li>ikcp_recv返回大于0的数的时候，buffer里面必然是一个完整的包。所谓完整的包，也就是对应发送方调用ikcp_send的时候发送的buffer。应该是一一对应的。原本我以为如果发送的包需要分段，那么需要把长度加到buffer前面，其实是没有必要的。因为peeksize就保证了，必须是一个完整的包才会返回大于0的数。</li>
<li>stream=0的话可以保证收到的是一个 send时传过去的完整的包。<a href="https://github.com/skywind3000/kcp/issues/76" target="_blank" rel="noopener">流模式和包模式的问题</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ikcp_peeksize</span><span class="params">(<span class="keyword">const</span> ikcpcb *kcp)</span></span></span><br></pre></td></tr></table></figure>

<p>检查接收队列中是否有一个完整的消息，并返回消息的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ickp_send</span><span class="params">(ikcpcb *kcp, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure>

<p>发送应用层的数据，会根据mtu大小分片，每个分片加上segment头部24字节，加入发送队列snd_queue。</p>
<p>根据stream字段区分流模式和消息模式。不同模式组包的机制不一样。如果是消息模式，分片数据的frg字段从count-1到0,0表示分片结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ikcp_update</span><span class="params">(ikcpcb *kcp, IUINT32 current)</span></span></span><br></pre></td></tr></table></figure>

<p>根据传入的时钟，决定是否调用flush。kcp维护一个ts_flush表示下一次flush的时间，update的时候如果发现当前时间已经大于等于ts_flush，则执行flush。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ikcp_nodelay</span><span class="params">(ikcpcb *kcp, <span class="keyword">int</span> nodelay, <span class="keyword">int</span> interval, <span class="keyword">int</span> resend, <span class="keyword">int</span> nc)</span></span></span><br></pre></td></tr></table></figure>

<p>配置参数。interval的范围是10ms到5000ms。默认是100ms。interval决定了实际调用flush的频率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ikcp_flush</span><span class="params">(ikcp *kcp)</span></span></span><br></pre></td></tr></table></figure>

<p>实际发送数据的接口。</p>
<ul>
<li>发送acklist中的ack消息</li>
<li>如果对方接收窗口为0，需要发送IKCP_CMD_WASK消息，检查probe对方接收窗口是否ready</li>
<li>发送自己的接收窗口大小</li>
<li>发送数据</li>
</ul>
<p>snd_buf 是一个带 sentinel 的循环链表。</p>
<p>ikcp_parse_una 接收端接收到数据包，解析出对端尚未确认的包，那么小于una的说明都已经确认，如果发送缓冲中还在，直接删除。<br>同时，由于接收端接收到了新的数据，所以需要更新自己的 send_una 也就是尚未确认收到的包。如果发送缓冲中有包，那么就是发送缓冲中的第一个包的sn。<br>否则就是下一个需要发送的sn：kcp-&gt;snd_nxt。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">TCP Congestion Control</a></li>
<li><a href="https://tools.ietf.org/html/rfc2525" target="_blank" rel="noopener">Known TCP Implementation Problems</a></li>
<li><a href="https://github.com/skywind3000/kcp/wiki/Flow-Control-for-Users" target="_blank" rel="noopener">https://github.com/skywind3000/kcp/wiki/Flow-Control-for-Users</a></li>
<li><a href="http://www.cnblogs.com/yuanyifei1/p/6830352.html" target="_blank" rel="noopener">kcp结构体字段含义</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/11/23/skill-area/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/11/23/skill-area/" class="post-title-link" itemprop="url">技能伤害区域计算</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-11-23 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-23T00:00:00+08:00">2017-11-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MMO游戏中经常需要实现各种技能的效果，不同技能拥有不同的伤害区域，<br>一般情况下，我们需要对周围的目标进行遍历，检查目标是否落在伤害区域内。<br>一般的伤害预期主要是三种：圆形，扇形，矩形。</p>
<h2 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h2><p>圆形伤害区域的计算非常简单，给点圆心C, 半径R, 计算P是否在圆内。<br>只需要计算P到C的欧式距离|P - C|是否小于R即可。为了节省开方计算，<br>我们可以直接用平方来比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">is_in_circle(#pb_vector3&#123;x = X, z = Z&#125; = P, #pb_vector3&#123;x = X0, z = Y0&#125;, R) -&gt;</span><br><span class="line">    Dx = X - X0,</span><br><span class="line">    Dz = Z - Z0,</span><br><span class="line">    Dx * Dx + Dz * Dz &lt; R * R.</span><br></pre></td></tr></table></figure>

<h2 id="扇形"><a href="#扇形" class="headerlink" title="扇形"></a>扇形</h2><p>扇形伤害区域的计算相对于圆形要复杂一点，<a href="http://www.cnblogs.com/miloyip/archive/2013/04/19/3029852.html" target="_blank" rel="noopener">Milo的文章</a>对扇形的处理有很好的阐述，可惜部分公式显示不出来了。<br>圆形相当于扇形的特殊形式。这里我们只考虑锐角扇形，即不超过180度的扇形。<br>给点圆心C, 半径R, 施法者朝向V, 扇形角度Thelta，P是在扇形内需要满足两个条件：</p>
<ul>
<li>P到C的欧式距离不超过R，跟圆形的判断一致。</li>
<li>P到V的夹角小于Thelta/2</li>
</ul>
<p>判断P到V的夹角有两种方式，一种是分别计算CP和V的与x轴的夹角，然后看这两个夹角检测这两个夹角的差值范围是否在Thelta/2范围内。<br>这个夹角可以通过atan2函数求得，这里要特别小心角度的范围。考虑到V是常数，可以预先算出夹角，可是还是免不了要计算一个atan2.<br>另一种办法是用点积。具体参考Milo的文章。</p>
<p>这里我们采用另外一种方法，这个方法来自<a href="https://stackoverflow.com/questions/13652518/efficiently-find-points-inside-a-circle-sector" target="_blank" rel="noopener">StackOverflow</a>, 这个方法需要算出扇形的起始向量，假设为StartVector，EndVector，<br>然后我们只需要判断CP是否在StartVector的逆时针方向，并且在EndVector的顺时针方向。<br>这里StartVector和EndVector都可以预先计算出来。而判断方向的方法异常简单:</p>
<p>检测v2是否在v1的顺时针方向：</p>
<ul>
<li>找到v1的逆时针法向量，法向量相当于将v1逆时针旋转90度：(x1, y1) -&gt; (-y1, x1)</li>
<li>找到v2在法向量上的投影，利用点积计算：p = v2.x * n1.x + v2.y * n1.y</li>
<li>如果投影为正，那么v2在v1的逆时针方向，否则为顺时针方向。</li>
</ul>
<p>我们的输入不包括扇形的两个向量，所以先要计算出这两个向量，根据欧拉公式：</p>
<p><strong>一定要注意sectorStart和sectorEnd都是相对于扇形圆心的坐标，而不是绝对坐标！！！！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%% #pb_vector3&#123;x = X0, z = Z0&#125; 为施法者坐标指向施法目标的向量</span><br><span class="line">Sin = math:sin(Thelta/2),</span><br><span class="line">Cos = math:cos(Thelta/2),</span><br><span class="line">SectorStart = #pb_vector3&#123;x = X0 * Cos + Z0 * Sin, y = 0, z = -X0 * Sin + Z0 * Cos&#125;,</span><br><span class="line">SectorEnd   = #pb_vector3&#123;x = X0 * Cos - Z0 * Sin, y = 0, z = X0 * Sin + Z0 * Cos&#125;,</span><br></pre></td></tr></table></figure>

<p>给点起始和结束向量，求解坐标是否在扇形内：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%% 判断V2是否在V1的顺时针方向</span><br><span class="line">are_clock_wise(#pb_vector3&#123;x = X1, z = Z1&#125;=V1, #pb_vector3&#123;x = X2, z = Z2&#125;=V2) -&gt;</span><br><span class="line">    -X1 * Z2 + Z1 * X2 &gt; 0.</span><br><span class="line"></span><br><span class="line">%% 是否在圆内</span><br><span class="line">is_within_radius(#pb_vector3&#123;x = X1, z = Z1&#125;, RadiusSquared) -&gt;</span><br><span class="line">    X1 * X1 + Z1 * Z1 =&lt; RadiusSquared.</span><br><span class="line"></span><br><span class="line">%% 是否在扇形内</span><br><span class="line">is_inside_sector(CheckPos, CastingPos, SectorStart, SectorEnd, RadiusSquared) -&gt;</span><br><span class="line">    RelPoint = lib_map_util:get_raw_vector(CastingPos, CheckPos),</span><br><span class="line">    (not are_clock_wise(SectorStart, RelPoint)) andalso</span><br><span class="line">    are_clock_wise(SectorEnd, RelPoint) andalso</span><br><span class="line">    is_within_radius(RelPoint, RadiusSquared).</span><br></pre></td></tr></table></figure>

<h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><p>给点施法者的位置C，施法者前方的终点坐标F，技能决定施法的范围Range，可以得到一个矩形区域。</p>
<p>矩形的计算也有几种方法，比如先进行坐标系的转换，在相对坐标系中判断就很简单了。不过坐标的转换略复杂。</p>
<p>这里采用的是另一种方法，通过求点到线段的距离来判断矩形区域。</p>
<ul>
<li>先判断点是否超出线段的起点和终点</li>
<li>若没有，则求出点到直线的距离</li>
</ul>
<p>根据点积可以判断坐标是否落在线段的中部。点积大于0且小于线段长度的平方说明坐标落在线段的中间区间，没有超出两端的范围。<br>如果没有超出两端，我们就可以算出点到直线的投影点，然后计算点到投影点的距离，从而得到点到直线的距离。</p>
<p>坐标的投影所占的线段的比例为：R = Dot / LengthSquared, 则投影点为：C + R * (F - C)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">is_in_rectangle(#pb_vector3&#123;x = X, z = Z&#125; = P, #pb_vector3&#123;x = X1, z = Z1&#125; = C, #pb_vector3&#123;x = X2, z = Z2&#125; = F, RangeSquared) -&gt;</span><br><span class="line">    Dx = X2 - X1,</span><br><span class="line">    Dz = Z2 - Z1,</span><br><span class="line">    LengthSquared = Dx * Dx + Dz * Dz,</span><br><span class="line">    Dot = Dx * (X - X1) + Dz * (Z - Z1),</span><br><span class="line">    Dot &gt;= 0 andalso Dot &lt; LengthSquared andalso begin</span><br><span class="line">        R = Dot / LengthSquared,</span><br><span class="line">        Xp = X1 + Dx * R,</span><br><span class="line">        Zp = Z1 + Dz * R,</span><br><span class="line">        (X-Xp)*(X-Xp) + (Z-Zp)*(Z-Zp) =&lt; RangeSquared</span><br><span class="line">    end.</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment" target="_blank" rel="noopener">https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rotation_matrix" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rotation_matrix</a></li>
<li><a href="https://www.w3schools.com/graphics/tryit.asp?filename=trycanvas_circle" target="_blank" rel="noopener">https://www.w3schools.com/graphics/tryit.asp?filename=trycanvas_circle</a></li>
</ul>
<h2 id="附扇形的检验程序"><a href="#附扇形的检验程序" class="headerlink" title="附扇形的检验程序"></a>附扇形的检验程序</h2><p>直接存到html文件在浏览器中执行即可，可以通过修改参数改变输出的图形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;400&quot;</span><br><span class="line">style=&quot;border:1px solid #d3d3d3;&quot;&gt;</span><br><span class="line">Your browser does not support the canvas element.</span><br><span class="line">&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function isInsideSector(point, center, sectorStart, sectorEnd, radiusSquared) &#123;</span><br><span class="line">    var relPoint = &#123;</span><br><span class="line">        x: point.x - center.x,</span><br><span class="line">        y: point.y - center.y</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return !areClockwise(sectorStart, relPoint) &amp;&amp;</span><br><span class="line">         areClockwise(sectorEnd, relPoint) &amp;&amp;</span><br><span class="line">         isWithinRadius(relPoint, radiusSquared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function areClockwise(v1, v2) &#123;</span><br><span class="line">    return -v1.x*v2.y + v1.y*v2.x &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isWithinRadius(v, radiusSquared) &#123;</span><br><span class="line">    return v.x*v.x + v.y*v.y &lt;= radiusSquared;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isInsideSector2(point,center, sectorStart, sectorEnd, radiusSquared) &#123;</span><br><span class="line">    var relPoint = &#123;</span><br><span class="line">        x: point.x - center.x,</span><br><span class="line">        y: point.y - center.y</span><br><span class="line">    &#125;;</span><br><span class="line">    return !areClockwise(sectorStart, relPoint) &amp;&amp;</span><br><span class="line">        areClockwise(sectorEnd, relPoint) &amp;&amp;</span><br><span class="line">        isWithinRadius(relPoint, radiusSquared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var canvasSize = 400;</span><br><span class="line">var canvas = document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">//ctx.beginPath();</span><br><span class="line">//ctx.arc(200,200,200,-Math.PI,0);</span><br><span class="line">//ctx.stroke();</span><br><span class="line"></span><br><span class="line">function drawLine(point) &#123;</span><br><span class="line">	ctx.moveTo(200,200);</span><br><span class="line">    ctx.lineTo(point.x, point.y);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var center = &#123; x: 200, y: 200 &#125;;</span><br><span class="line">var sectorStart = &#123; x: 400, y: 200 &#125;;</span><br><span class="line">var sectorEnd = &#123; x: 200, y: 400 &#125;;</span><br><span class="line">drawLine(sectorStart);</span><br><span class="line">drawLine(sectorEnd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 800; ++i) &#123;</span><br><span class="line"></span><br><span class="line">    // generate a random point</span><br><span class="line">    var point = &#123;</span><br><span class="line">      x: Math.random() * canvasSize,</span><br><span class="line">      y: Math.random() * canvasSize</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var sectorCenter = &#123;x:0,y:200&#125;;</span><br><span class="line">    var cx = sectorCenter.x - center.x;</span><br><span class="line">    var cy = sectorCenter.y - center.y;</span><br><span class="line">    var thelta = Math.PI/4;</span><br><span class="line">    var sin = Math.sin(thelta);</span><br><span class="line">    var cos = Math.cos(thelta);</span><br><span class="line">    var sectorStart = &#123;</span><br><span class="line">        x: cx*cos + cy*sin,</span><br><span class="line">        y: -cx*sin + cy*cos</span><br><span class="line">    &#125;;</span><br><span class="line">    var sectorEnd = &#123;</span><br><span class="line">        x: cx*cos - cy*sin,</span><br><span class="line">        y: cx*sin + cy*cos</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // test if the point is inside the sector</span><br><span class="line">    var isInside = isInsideSector2(point, center, sectorStart,sectorEnd, 40000);</span><br><span class="line">    //var isInside = isInsideSector(point, center, &#123;x:200,y:0&#125;, &#123;x:0,y:200&#125;, 40000);</span><br><span class="line"></span><br><span class="line">    // draw the point</span><br><span class="line">    if (isInside) &#123;</span><br><span class="line">        drawLine(point);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/10/09/tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/10/09/tcp/" class="post-title-link" itemprop="url">TCP那些事儿</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-10-09T00:00:00+08:00">2017-10-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>面向连接，一对一，所以基于广播和多播的应用程序不能使用TCP服务。而无连接的UDP则非常适合广播和多播。</li>
<li>字节流，TCP 字节流，send()写recv()读次数没有固定关系，UDP 数据报，sendto()写recvfrom()读次数相同。</li>
<li>可靠传输。</li>
</ul>
<p>传输层-Segment, 网络层-Packet, 链路层-Frame</p>
<h2 id="TCP-HEADER"><a href="#TCP-HEADER" class="headerlink" title="TCP HEADER"></a>TCP HEADER</h2><p><img src="tcp-header.png" alt="tcp-header"></p>
<ul>
<li>32位序号sequence number, ISN + byte offset of the first byte in the packet<ul>
<li>ISN initial sequence number, random generated</li>
</ul>
</li>
<li>4 bit header length: unit 32bit，4字节。<ul>
<li>min = 5，最小为5，表示没有选项，头部长度为：5 * 4 = 20</li>
<li>max = 15，4 比特最大能表示15，15 * 4 = 60，表示选项不能超过 40 字节。</li>
</ul>
</li>
<li>Flags<ul>
<li>URG</li>
<li>ACK</li>
<li>PSH</li>
<li>RST</li>
<li>SYN</li>
<li>FIN</li>
</ul>
</li>
<li>RWND receiver window，接收窗口，每个包都会携带。这个数据非常重要。决定了发送端的发包策略，即滑动窗口机制实现的接收端流量控制。通过控制发送端的发送窗口实现对接收方的流量控制。2 字节，最大64k？超过64k怎么办？tcp_window_scaling。最大可到1G。rfc 1323，通过选项的窗口的扩大因子。</li>
<li>checksum crc(header + data)</li>
<li>options &lt;= 40 byte</li>
</ul>
<h3 id="tcp-选项"><a href="#tcp-选项" class="headerlink" title="tcp 选项"></a>tcp 选项</h3><p>分为单字节的选项和可变长度的选项：</p>
<ul>
<li>单字节选项由一个字节的选项类型 Option Kind 构成。</li>
<li>可变长度选项由 1 字节的选项类型，1 字节的选项长度，加可变长度的选项数据构成。</li>
</ul>
<p><img src="tcp-options.png" alt="tcp-options"></p>
<ul>
<li><p>kind 1, length 1, info n</p>
</li>
<li><p>kind:</p>
<ul>
<li><p>0 terminate，用于选项列表的结束。</p>
</li>
<li><p>1 nop，用在两个选项之间，用于选项结构的对齐。</p>
</li>
<li><p>2 MSS(Max Segment Size), 最大报文长度，单位是字节数，最大能表示64k，因为选项数据的长度是2字节。选项长度为4，1+1+2，以太网MTU为1500字节，减去TCP、IP头部40字节，MSS还剩1460字节。只能用于初始化连接的报文中 (SYN = 1)。目标：尽量多的传输数据，避免切片。不大于接收缓冲区。MSS 的长度为 MTU - 40 字节的固定长度。发送端保证 tcp 数据长度不超过 MSS - tcp和ip 选项的长度。rfc 6691</p>
<blockquote>
<p>The MSS value to be sent in an MSS option should be equal to the<br>effective MTU minus the fixed IP and TCP headers.  By ignoring both<br>IP and TCP options when calculating the value for the MSS option, if<br>there are any IP or TCP options to be sent in a packet, then the<br>sender must decrease the size of the TCP data accordingly.</p>
</blockquote>
</li>
<li><p>3 window scale, 窗口扩大因子。0~14, /proc/sys/net/ipv4/tcp_window_scaling only for syn, rfc1323</p>
</li>
<li><p>8 timestamp for rtt calculation  时间戳选项 /proc/sys/net/ipv4/tcp_timestamps<br>4，5，6，7 都用于ack选择和回显。</p>
</li>
<li><p>4 sack-permitted only in syn, /proc/sys/net/ipv4/tcp_sack</p>
</li>
<li><p>5 sack content<br>11，12，13 用于 tcp 事务</p>
</li>
</ul>
</li>
</ul>
<h4 id="sack-（tcp-selective-acknowledgments）"><a href="#sack-（tcp-selective-acknowledgments）" class="headerlink" title="sack （tcp selective acknowledgments）"></a>sack （tcp selective acknowledgments）</h4><p>选择性确认，可通过 <code>/proc/sys/net/ipv4/tcp_sack</code> 配置开关。Linux 2.4以后默认打开，不过需要两边都打开才能生效。<br>发生丢包以后，发送端要么重传所有从丢包的包以后的所有包，要么发送丢失的包以后再等待一个RTT时间来发现下一个要传的包。<br>选择确认机制就是为了解决这个问题。接收端可以告诉发送端哪些包收到了，发送端只需要发送未收到的包即可。提高了效率。</p>
<h2 id="TCP-状态转移"><a href="#TCP-状态转移" class="headerlink" title="TCP 状态转移"></a>TCP 状态转移</h2><p><img src="tcp_status.jpg" alt="tcp-status"></p>
<p>主动断开连接的一方，在连接关闭以后进入TIME_WAIT状态, 需要等待2*MSL(Maximum Segment Life) 报文段最大生存时间，rfc1122建议2min。<br>TIME_WAIT存在的原因：</p>
<ul>
<li>可靠的终止TCP连接。</li>
<li>保证让迟来的TCP报文段有足够的时间被识别并丢弃。</li>
</ul>
<p>服务器主动关闭连接后，监听的端口处于TIME_WAIT状态导致它不能立即重启，需要设置socket选项SO_REUSEADDR来强制进程立即使用处于TIME_WAIT状态占用的端口。<br>正常终止连接需要四步握手。TCP还提供了异常终止连接的办法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端素有排队等待发送的数据都将被丢弃。<br>应用程序可以使用socket选项SO_LINGER来发送复位报文段，以异常终止一个连接。</p>
<h2 id="TCP-流控"><a href="#TCP-流控" class="headerlink" title="TCP 流控"></a>TCP 流控</h2><p>发送方如果发送太快导致接收端来不及接收就会导致丢包。流量控制就是让发送方发送速率不要太快，要让接收方来得及接收。<br>TCP使用滑动窗口机制来实现对发送方的流量控制。</p>
<ul>
<li>滑动窗口 Sliding Window<br>  接收端向发送端通告自己的接收窗口rwnd大小，表示接收方能够接收的字节数。<br>  发送端维护一个发送窗口swnd，保存已发送且尚未收到ack的包。发送窗口不大于接收方的rwnd。<br>  当接收窗口为0的时候，发送端需要设置持续计时器，persistence timer, 触发发送ZWP(Zero Window Probe)探测接收端的接收窗口大小（Zero Window Probe Ack）。<pre><code>wireshark中使用tcp.analysis.zero_window过滤包，然后后右键follow TCP stream</code></pre>  有等待的地方就会可能出现DDos攻击，Zero Window也不例外，一种可能的攻击方式：<pre><code>攻击者跟服务器建立连接后发送GET请求，然后将窗口设置为0，服务端只能等待进行ZWP，攻击者并发大量这样的请求，把服务器资源耗尽(sockstress)。</code></pre>  一般会探测3次，每次30-60秒，如果3次过后还是0，有的TCP就会发RST把链接断开。<br>  发送方的发送数据可以分为：<pre><code>- 已经收到ack确认的数据
- 已经发送但是未收到ack确认的数据
- 可以发送的数据（接收方还有空间）
- 不能发送的数据（接收方没有空间）</code></pre>  中间两者加起来就是发送窗口。</li>
<li>Nagle算法(TCP_NODELAY) RFC896 (Congestion Control in IP/TCP internetworks)<ul>
<li>if there are unacknowledged in-flight data, new data is buffered</li>
<li>if the data to be send is &lt; MSS, it is buffered until MSS<br>When to send data (rfc 1122)<ul>
<li>Immediately if a full MSS size package can be sent (at least MSS data is accumulated)</li>
<li>All previously sent data has been acknowledged AND ((PSH flag is set) OR buffered data &gt; 1/2 * send window)</li>
<li>PSH flag is set AND the override timeout(0.1 … 1s) expired<br>针对小包应用的优化。发送方发包的时机，发送方收到对方上一个包的确认后才发送下一个包。确认快那么发送也快，确认慢则发送慢，<br>可以根据网速动态调整速率。网速慢时可以显著减少网络上报文的数量。对于实时性要求高的应用如telnet，ssh，mmoarpg，应该要关闭Nagle算法。<br>糊涂窗口综合征 Silly Window Syndrom<br>接收窗口已满，而交互式应用一次只从接收缓存中读取一个字节，然后向发送方发送确认，并把窗口设置成1个字节。如此往复，网络效率低。<br>解决的办法是避免对小的window size做出响应，知道有足够大的window size再响应：<br>接收方：David D Clark’s方案，等到缓存有足够的空间容纳一个MSS，或者接收缓存已有一半空闲空间的时候才向发送端回确认报文。<br>发送端：Nagle’s algorithm 不要发送太小的报文，而是把数据报累积成足够大的报文段，或者达到接收方缓存空间一半大小。<br>Nagle + Delay ack 导致延迟 内格尔算法，纳格算法。john nagle<br>ACK is delayed until return data is available(piggy-backing of ack) or until delayed ack timer expires<br>MSS: 最大报文长度 maximum segment size，通过 tcp 协议的选项字段协商。建立连接时协商，根据双方提供的 MSS 最小值决定。实现时往往用 MTU 代替。需要减去 ip 头 20 字节和 tcp 头 20字节，所以是 1460。是 tcp 报文中的数据最大长度。数据字段加上头部才是整个报文的长度。MSS = tcp 报文长度 - tcp 头部长度。<br><a href="https://tools.ietf.org/html/rfc6691" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6691</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="超时重传RTO（Retransmission-timeout）"><a href="#超时重传RTO（Retransmission-timeout）" class="headerlink" title="超时重传RTO（Retransmission timeout）"></a>超时重传RTO（Retransmission timeout）</h2><p>RTO计算方法见<a href="https://tools.ietf.org/rfc/rfc6298.txt" target="_blank" rel="noopener">Computing TCP’s Retransmission Timer</a>，主要维护两个变量：</p>
<ul>
<li>SRTT: smoothed round-trip time</li>
<li>RTTVAR: round-trip time variation</li>
</ul>
<p>计算过程如下：</p>
<ul>
<li><p>初始化先设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO = 1 or 3 seconds;</span><br></pre></td></tr></table></figure>
</li>
<li><p>报文超时，重传以后设置改报文新的超时时间为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO = RTO * 2 (back off the timer)</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新srtt和rttvar之后，计算新的rro：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RTO = SRTT + max(G, K*TRRVAR);</span><br><span class="line">RTO &lt; 1 then RTO = 1;</span><br><span class="line">RTO &gt; 60 then RTO = 60;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>srtt和rttvar的计算过程如下：</p>
<ul>
<li>收到第一个ACK以后，设置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRTT = R;</span><br><span class="line">RTTVAR = R / 2;</span><br></pre></td></tr></table></figure>

<ul>
<li>收到后续的ACK，依次设置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RTTVAR = (1 - bata) * RTTVAR + bata * |SRTT - R&apos;|;</span><br><span class="line">SRTT = (1 - alpha) * SRTT + alpha * R&apos;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alpha = 1/8, beta = 1/4</span><br></pre></td></tr></table></figure>

<p>不能用重传的包来计算rtt, 因为无法确定包是哪个时间点发出的，除非包本身有timestamp。</p>
<h2 id="拥塞控制算法-congestion-control-algorithm"><a href="#拥塞控制算法-congestion-control-algorithm" class="headerlink" title="拥塞控制算法 congestion control algorithm"></a>拥塞控制算法 congestion control algorithm</h2><p>最大化网络上瓶颈链路的带宽。提高网络利用率，降低丢包率，保证公平性。RFC5681</p>
<ul>
<li>慢启动和拥塞避免 slow start and congestion avoidance</li>
<li>快速重传和快速恢复 fast retransmit / fast recovery</li>
</ul>
<p>Linux下课通过sysctl查看使用的拥塞算法，</p>
<p>$ sysctl -a | grep congestion_control<br>net.ipv4.tcp_congestion_control = cubic<br>net.ipv4.tcp_available_congestion_control = cubic reno<br>net.ipv4.tcp_allowed_congestion_control = cubic reno</p>
<p>通过 /proc/sys/net/ipv4/tcp_congestion_control 可以控制使用的拥塞算法。</p>
<p>主要的实现算法有:</p>
<ul>
<li>loss based congestion control (bufferbloat problem)<ul>
<li>reno</li>
<li>vegas</li>
<li>cubic 看了下centos下都是cubic</li>
</ul>
</li>
<li>bbr (Bottleneck Bandwidth and RTT)google最新推出的</li>
</ul>
<p>if CWND &lt; ssthresh<br>slow start cwnd每个rtt扩大一倍，指数扩大</p>
<ul>
<li>IW</li>
<li>CWND += min(N, SMSS)</li>
</ul>
<p>if CWND &gt; ssthresh</p>
<ul>
<li>CWND += SMSS*SMSS/CWND cwnd每个rtt加1</li>
</ul>
<p>早期拥塞避免阶段的cwnd计算公式为：<code>cwnd += (MSS * MSS / cwnd) + MSS/8</code>，<br>rfc2525指出了Extra additive constant in congestion avoidance，带来的问题，<br>即公式后面多余的部分会导致一个RTT内多个包丢失而无法通过快速重传恢复，从而导致超时重传，从而降低性能。<br>正确的做法应该是去掉后面的部分：<code>cwnd += (MSS * MSS / cwnd)</code>。</p>
<p>如果CWND=ssthresh，慢启动或者拥塞避免随意。</p>
<p>发送端判断拥塞：</p>
<ul>
<li>传输超时，tcp重传定时器溢出：慢启动和拥塞避免<ul>
<li>ssthresh = max(FlightSize/2, 2*MSS)</li>
<li>CWND &lt;= SMSS</li>
<li>再次进入慢启动</li>
</ul>
</li>
</ul>
<p><img src="slow-start-and-congestion-avoidance.png" alt="slow-start-and-congestion-avoidance"></p>
<ul>
<li>接收到重复的确认报文：快速重传，快速恢复<ul>
<li>接收端收到失序报文立即发送重复确认，而不必等待自己发送数据时捎带确认</li>
<li>发送端收到前两个重复确认时，在允许的情况下应该发送一个之前尚未发送的数据包，(FlightSize &lt;= cwnd+2*MSS), CWND保持不变。</li>
<li>发送端收到3个重复确认报文立即重发对方未收到的报文，而不必等待超时。<br>ssthresh=max(FlightSize/2, 2<em>MSS), CWND = ssthresh + 3</em>MSS，加3是因为收到了3个重复ack报文，意味着有三个报文离开了网络。</li>
<li>每收到一个重复确认：CWND = CWND + SMSS，每收到一个重复确认，那么有一个报文离开了网络。</li>
<li>收到新数据确认：CWND = ssthresh</li>
<li>快速重传和快速恢复完成之后，恢复到拥塞避免阶段</li>
</ul>
</li>
</ul>
<p><img src="fast-retransmit.png" alt="fast-retransmit"><br><img src="fast-recovery.png" alt="fast-recovery"></p>
<h3 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h3><p>传统的拥塞控制算法存在两个问题：</p>
<ul>
<li><p>无法区分丢包类型，错误丢包和拥塞丢包</p>
</li>
<li><p>缓冲膨胀区问题</p>
<ul>
<li>增加网络延时</li>
<li>缓冲区被填满而丢包<br>google新出的拥塞控制算法。</li>
</ul>
</li>
<li><p>既然不容易区分拥塞丢包和错误丢包，TCP BBR 就干脆不考虑丢包。</p>
</li>
<li><p>既然灌满水管的方式容易造成缓冲区膨胀，TCP BBR 就分别估计带宽和延迟，而不是直接估计水管的容积。</p>
</li>
<li><p>在有一定丢包率的网络链路上充分利用带宽。</p>
</li>
<li><p>降低网络链路上的buffer占用率，从而降低延迟。</p>
</li>
</ul>
<h2 id="随机早期检测RED"><a href="#随机早期检测RED" class="headerlink" title="随机早期检测RED"></a>随机早期检测RED</h2><p>random early detection</p>
<p>网络层的策略对拥塞控制算法影响最大的就是路由器的丢弃策略。在简单的情况下，路由器通常按照先进先出的策略处理到来的分组。<br>当路由器的缓存装不下分组的时候就丢弃到来的分组，这就叫尾部丢弃策略。这样会导致分组丢失，发送方认为网络产生阻塞。<br>当网络中存在很多TCP连接，若发生路由器的尾部丢弃，可能影响很多条TCP连接，结果就是很多TCP同一时间进入slow start状态。<br>这种情况称为全局同步。全局同步回事网络的通信量突然下降很多，而在网络恢复正常以后，通信量又突然增大很多。</p>
<p>为避免产生网络中的全局同步现象，路由器采用随机早期检测算法：<br>路由器的队列维持两个参数，队列最小门限min和最大门限max，每当一个分组到来的时候，RED就计算平均队列长度。然后分情况对待到来的分组：</p>
<ul>
<li>平均队列长度小于最小门限，将新分组加入队列排队。</li>
<li>平均队列长度在min和max之间，按照概率丢弃分组。</li>
<li>平均队列长度大于max，丢弃分组。<br>以概率p随机丢弃分组，让拥塞控制只在个别的TCP连接上执行，因而避免全局性的拥塞控制。</li>
</ul>
<p><img src="red.png" alt="red"></p>
<p>RED的关键就是选择三个参数：最小门限，最大门限，丢弃概率以及计算平均队列长度。<br>平均队列长度采用加权的方法计算，跟计算RTT的策略一样。</p>
<p><img src="red-la.png" alt="red-la"></p>
<h2 id="针对TCP的攻击"><a href="#针对TCP的攻击" class="headerlink" title="针对TCP的攻击"></a>针对TCP的攻击</h2><ul>
<li>syn flood 攻击方发送大量syn，耗尽服务器资源。</li>
<li>zero window probe，攻击方建立连接以后通知自己窗口为0，被攻击放只能隔三差五发个zwp包去问一下。</li>
</ul>
<h2 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h2><p>以太网一般为1500字节，拨号网为576.<br>802.11 MTU: 2304<br>    MTU + MAC Header + Encryption Header<br>    WEP: 2304 + 34 + 8 = 2346 bytes<br>    WPA(TKIP): 2304 + 34 + 20 = 2358 bytes<br>    WPA2(CCMP): 2304 + 34 + 16 = 2354 bytes</p>
<h2 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h2><p>4元祖。ip地址改变（比如wifi切换到移动网络）或者端口改变时（当客户端的nat绑定超时导致服务器看到的端口号改变）连接会断掉。<br>尽管MPTCP解决了TCP的连接迁移问题，但依然缺少中间设备和OS部署支持。</p>
<h2 id="锐速"><a href="#锐速" class="headerlink" title="锐速"></a>锐速</h2><p>一个TCP加速软件，被用来加速VPS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f</span><br></pre></td></tr></table></figure>

<ul>
<li>/serverspeeder/bin/serverSpeeder.sh restart</li>
<li>/serverspeeder/bin/serverSpeeder.sh start</li>
<li>/serverspeeder/bin/serverSpeeder.sh stop</li>
<li>/serverspeeder/bin/serverSpeeder.sh status</li>
</ul>
<h2 id="tcp参数"><a href="#tcp参数" class="headerlink" title="tcp参数"></a><a href="https://tonydeng.github.io/2015/05/25/linux-tcpip-tuning/" target="_blank" rel="noopener">tcp参数</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">net.core.netdev_max_backlog = 400000</span><br><span class="line">#该参数决定了，网络设备接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span><br><span class="line">net.core.optmem_max = 10000000</span><br><span class="line">#该参数指定了每个套接字所允许的最大缓冲区的大小</span><br><span class="line">net.core.rmem_default = 10000000</span><br><span class="line">#指定了接收套接字缓冲区大小的缺省值（以字节为单位）。</span><br><span class="line">net.core.rmem_max = 10000000</span><br><span class="line">#指定了接收套接字缓冲区大小的最大值（以字节为单位）。</span><br><span class="line">net.core.somaxconn = 100000</span><br><span class="line">#Linux kernel参数，表示socket监听的backlog(监听队列)上限</span><br><span class="line">net.core.wmem_default = 11059200</span><br><span class="line">#定义默认的发送窗口大小；对于更大的 BDP 来说，这个大小也应该更大。</span><br><span class="line">net.core.wmem_max = 11059200</span><br><span class="line">#定义发送窗口的最大大小；对于更大的 BDP 来说，这个大小也应该更大。</span><br><span class="line">net.ipv4.conf.all.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">#严谨模式 1 (推荐)</span><br><span class="line">#松散模式 0</span><br><span class="line">net.ipv4.tcp_congestion_control = bic</span><br><span class="line">#默认推荐设置是 htcp</span><br><span class="line">net.ipv4.tcp_window_scaling = 0</span><br><span class="line">#关闭tcp_window_scaling</span><br><span class="line">#启用 RFC 1323 定义的 window scaling；要支持超过 64KB 的窗口，必须启用该值。</span><br><span class="line">net.ipv4.tcp_ecn = 0</span><br><span class="line">#把TCP的直接拥塞通告(tcp_ecn)关掉</span><br><span class="line">net.ipv4.tcp_sack = 1</span><br><span class="line">#关闭tcp_sack</span><br><span class="line">#启用有选择的应答（Selective Acknowledgment），</span><br><span class="line">#这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）；</span><br><span class="line">#（对于广域网通信来说）这个选项应该启用，但是这会增加对 CPU 的占用。</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 10000</span><br><span class="line">#表示系统同时保持TIME_WAIT套接字的最大数量</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8192</span><br><span class="line">#表示SYN队列长度，默认1024，改成8192，可以容纳更多等待连接的网络连接数。</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br><span class="line">#开启TCP时间戳</span><br><span class="line">#以一种比重发超时更精确的方法（请参阅 RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line">net.ipv4.tcp_fin_timeout = 10</span><br><span class="line">#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1800</span><br><span class="line">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为30分钟。</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line">#如果对方不予应答，探测包的发送次数</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 15</span><br><span class="line">#keepalive探测包的发送间隔</span><br><span class="line">net.ipv4.tcp_mem</span><br><span class="line">#确定 TCP 栈应该如何反映内存使用；每个值的单位都是内存页（通常是 4KB）。</span><br><span class="line">#第一个值是内存使用的下限。</span><br><span class="line">#第二个值是内存压力模式开始对缓冲区使用应用压力的上限。</span><br><span class="line">#第三个值是内存上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的 BDP 可以增大这些值（但是要记住，其单位是内存页，而不是字节）。</span><br><span class="line">net.ipv4.tcp_rmem</span><br><span class="line">#与 tcp_wmem 类似，不过它表示的是为自动调优所使用的接收缓冲区的值。</span><br><span class="line">net.ipv4.tcp_wmem = 30000000 30000000 30000000</span><br><span class="line">#为自动调优定义每个 socket 使用的内存。</span><br><span class="line">#第一个值是为 socket 的发送缓冲区分配的最少字节数。</span><br><span class="line">#第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。</span><br><span class="line">#第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）。</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000</span><br><span class="line">#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</span><br><span class="line">net.ipv4.netfilter.ip_conntrack_max=204800</span><br><span class="line">#设置系统对最大跟踪的TCP连接数的限制</span><br><span class="line">net.ipv4.tcp_slow_start_after_idle = 0</span><br><span class="line">#关闭tcp的连接传输的慢启动，即先休止一段时间，再初始化拥塞窗口。</span><br><span class="line">net.ipv4.route.gc_timeout = 100</span><br><span class="line">#路由缓存刷新频率，当一个路由失败后多长时间跳到另一个路由，默认是300。</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line">#在内核放弃建立连接之前发送SYN包的数量。</span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line"># 避免放大攻击</span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br><span class="line"># 开启恶意icmp错误消息保护</span><br><span class="line">net.inet.udp.checksum=1</span><br><span class="line">#防止不正确的udp包的攻击</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">#是否接受含有源路由信息的ip包。参数值为布尔值，1表示接受，0表示不接受。</span><br><span class="line">#在充当网关的linux主机上缺省值为1，在一般的linux主机上缺省值为0。</span><br><span class="line">#从安全性角度出发，建议你关闭该功能。</span><br></pre></td></tr></table></figure>

<h2 id="三步握手"><a href="#三步握手" class="headerlink" title="三步握手"></a>三步握手</h2><p><a href="https://102.alibaba.com/detail?id=140" target="_blank" rel="noopener">https://102.alibaba.com/detail?id=140</a></p>
<p>cat /proc/sys/net/ipv4/tcp_max_syn_backlog  # 默认 128<br>ss -lnt # Send-Q 表示backlog值。Recv-Q表示当前使用的</p>
<p>半连接队列 max(64,  /proc/sys/net/ipv4/tcp_max_syn_backlog)     syns queue, syn floods 攻击<br>全连接队列 min(backlog, /proc/sys/net/core/somaxconn)           accept queue，如果全队列满了，根据tcp_abort_on_overflow指示执行。</p>
<p>netstat -nt     # w/o servers，Recv-Q就是指收到的数据还在缓存中，还没被进程读取，这个值就是还没被进程读取的 bytes；而 Send 则是发送队列中没有被远程主机确认的 bytes 数<br>netstat -nlt    # only servers</p>
<p>比如如下netstat -t 看到的Recv-Q有大量数据堆积，那么一般是CPU处理不过来导致的。<br>netstat -s<br>    overflowed: 全连接队列溢出<br>    ignored</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://stackoverflow.com/questions/1803566/what-is-the-cost-of-many-time-wait-on-the-server-side" target="_blank" rel="noopener">https://stackoverflow.com/questions/1803566/what-is-the-cost-of-many-time-wait-on-the-server-side</a></li>
<li><a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">TCP Congestion Control</a></li>
<li><a href="https://tools.ietf.org/html/rfc6817" target="_blank" rel="noopener">Low Extra Delay Background Transport (LEDBAT)</a></li>
<li><a href="https://tools.ietf.org/rfc/rfc6298.txt" target="_blank" rel="noopener">Computing TCP’s Retransmission Timer</a></li>
<li>Linux高性能服务器编程</li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next.git/commit/?id=0f8782ea14974ce992618b55f0c041ef43ed0b78" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next.git/commit/?id=0f8782ea14974ce992618b55f0c041ef43ed0b78</a></li>
<li><a href="http://netdevconf.org/1.2/slides/oct5/04_Making_Linux_TCP_Fast_netdev_1.2_final.pdf" target="_blank" rel="noopener">http://netdevconf.org/1.2/slides/oct5/04_Making_Linux_TCP_Fast_netdev_1.2_final.pdf</a></li>
<li><a href="http://queue.acm.org/detail.cfm?id=3022184" target="_blank" rel="noopener">http://queue.acm.org/detail.cfm?id=3022184</a></li>
<li><a href="https://www.zhihu.com/question/53559433" target="_blank" rel="noopener">https://www.zhihu.com/question/53559433</a></li>
<li><a href="http://blog.csdn.net/dog250/article/details/52879298" target="_blank" rel="noopener">http://blog.csdn.net/dog250/article/details/52879298</a></li>
<li><a href="https://github.com/91yun/serverspeeder" target="_blank" rel="noopener">https://github.com/91yun/serverspeeder</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/09/30/ssh-key-auth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/09/30/ssh-key-auth/" class="post-title-link" itemprop="url">ssh key auth</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-09-30 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-30T00:00:00+08:00">2017-09-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>the work flow:</p>
<ul>
<li>use ssh-keygen to generate a pair of private and public keys.</li>
<li>use ssh-copy-id or scp to copy files across local and remote server</li>
<li>add public key to authorized_keys</li>
<li>use private key to login</li>
</ul>
<p><img src="ssh-key-auth-flow.png" alt="ssh-key-auth"></p>
<h2 id="server-side"><a href="#server-side" class="headerlink" title="server side"></a>server side</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .ssh</span><br><span class="line">chmod 700 .ssh</span><br><span class="line"></span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line"></span><br><span class="line">chmod 600 authorized_keys</span><br><span class="line">chmod 600 id_rsa</span><br></pre></td></tr></table></figure>

<p>optional:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 622 id_rsa.pub</span><br></pre></td></tr></table></figure>

<h2 id="client-side"><a href="#client-side" class="headerlink" title="client side"></a>client side</h2><p>add hostname to hosts file, so we don’t have to remember the ip address every time we try to login the server.<br>although it’s not required to do so, we will introduce another way to specify hostname and login user for servers later.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .ssh</span><br><span class="line">scp user@remotehost:/home/user/.ssh/id_rsa ./ssh</span><br></pre></td></tr></table></figure>

<p>note: copy paste may not working, here we use scp to get the private key, and ssh-copy-id is recommended.</p>
<p>try:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@remotehost</span><br></pre></td></tr></table></figure>

<p>if the key pair is generated on the client side, then:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">centos6: ssh-copy-id -i ~/.ssh/id_rsa.pub &quot;zsy@10.1.0.3 -p 22222&quot;</span><br><span class="line">centos7: ssh-copy-id -i ~/.ssh/id_rsa.pub zsy@10.1.0.3 -p 22222</span><br><span class="line">or</span><br><span class="line">cat ~/.ssh/id_rsa.pub | ssh -p 22 zsy@10.1.0.3 &quot;umask 077;mkdir -p ~/.ssh;cat - &gt;&gt; ~/.ssh/authorized_keys&quot;</span><br></pre></td></tr></table></figure>

<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>add these lines to file <code>~/.ssh/config</code>, as before, <code>chmod 600 ~/.ssh/config</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">host shortname1</span><br><span class="line">    hostname server_ip_1</span><br><span class="line">    user user1</span><br><span class="line">    port 22</span><br><span class="line">    ##IdentityFile somefile</span><br><span class="line"></span><br><span class="line">host shortname2</span><br><span class="line">    hostname server_ip_2</span><br><span class="line">    user user2</span><br><span class="line">    port 22</span><br></pre></td></tr></table></figure>

<p>then you can type <code>ssh shortname1</code> or <code>ssh shortname2</code> to login.</p>
<h2 id="more-about-config"><a href="#more-about-config" class="headerlink" title="more about config"></a>more about config</h2><p>some enties:</p>
<ul>
<li>Host: Defines for which host or hosts the configuration section applies. The section ends with a new Host section or the end of the file. A single * as a pattern can be used to provide global defaults for all hosts.</li>
<li>HostName : Specifies the real host name to log into. Numeric IP addresses are also permitted.</li>
<li>User : Defines the username for the SSH connection.</li>
<li>IdentityFile : Specifies a file from which the user’s DSA, ECDSA or DSA authentication identity is read. The default is ~/.ssh/identity for protocol version 1, and ~/.ssh/id_dsa, ~/.ssh/id_ecdsa and ~/.ssh/id_rsa for protocol version 2.</li>
<li>ProxyCommand : Specifies the command to use to connect to the server. The command string extends to the end of the line, and is executed with the user’s shell. In the command string, any occurrence of %h will be substituted by the host name to connect, %p by the port, and %r by the remote user name. The command can be basically anything, and should read from its standard input and write to its standard output. This directive is useful in conjunction with nc(1) and its proxy support. For example, the following directive would connect via an HTTP proxy at 192.1.0.253: <code>ProxyCommand /usr/bin/nc -X connect -x 192.1.0.253:3128 %h %p</code></li>
<li>LocalForward : Specifies that a TCP port on the local machine be forwarded over the secure channel to the specified host and port from the remote machine. The first argument must be [bind_address:]port and the second argument must be host:hostport.</li>
<li>Port : Specifies the port number to connect on the remote host.</li>
<li>Protocol : Specifies the protocol versions ssh(1) should support in order of preference. The possible values are 1 and 2.</li>
<li>ServerAliveInterval : Sets a timeout interval in seconds after which if no data has been received from the server, ssh(1) will send a message through the encrypted channel to request a response from the server.</li>
<li>ServerAliveCountMax : Sets the number of server alive messages which may be sent without ssh(1) receiving any messages back from the server. If this threshold is reached while server alive messages are being sent, ssh will disconnect from the server, terminating the session.</li>
</ul>
<p>a more detailed example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">### default for all ##</span><br><span class="line">Host *</span><br><span class="line">     ForwardAgent no</span><br><span class="line">     ForwardX11 no</span><br><span class="line">     ForwardX11Trusted yes</span><br><span class="line">     User nixcraft</span><br><span class="line">     Port 22</span><br><span class="line">     Protocol 2</span><br><span class="line">     ServerAliveInterval 60</span><br><span class="line">     ServerAliveCountMax 30</span><br><span class="line"></span><br><span class="line">## override as per host ##</span><br><span class="line">Host server1</span><br><span class="line">     HostName server1.cyberciti.biz</span><br><span class="line">     User nixcraft</span><br><span class="line">     Port 4242</span><br><span class="line">     IdentityFile /nfs/shared/users/nixcraft/keys/server1/id_rsa</span><br><span class="line"></span><br><span class="line">## Home nas server ##</span><br><span class="line">Host nas01</span><br><span class="line">     HostName 192.168.1.100</span><br><span class="line">     User root</span><br><span class="line">     IdentityFile ~/.ssh/nas01.key</span><br><span class="line"></span><br><span class="line">## Login AWS Cloud ##</span><br><span class="line">Host aws.apache</span><br><span class="line">     HostName 1.2.3.4</span><br><span class="line">     User wwwdata</span><br><span class="line">     IdentityFile ~/.ssh/aws.apache.key</span><br><span class="line"></span><br><span class="line">## Login to internal lan server at 192.168.0.251 via our public uk office ssh based gateway using ##</span><br><span class="line">## $ ssh uk.gw.lan ##</span><br><span class="line">Host uk.gw.lan uk.lan</span><br><span class="line">     HostName 192.168.0.251</span><br><span class="line">     User nixcraft</span><br><span class="line">     ProxyCommand  ssh nixcraft@gateway.uk.cyberciti.biz nc %h %p 2&gt; /dev/null</span><br><span class="line"></span><br><span class="line">## Our Us Proxy Server ##</span><br><span class="line">## Forward all local port 3128 traffic to port 3128 on the remote vps1.cyberciti.biz server ##</span><br><span class="line">## $ ssh -f -N  proxyus ##</span><br><span class="line">Host proxyus</span><br><span class="line">    HostName vps1.cyberciti.biz</span><br><span class="line">    User breakfree</span><br><span class="line">    IdentityFile ~/.ssh/vps1.cyberciti.biz.key</span><br><span class="line">    LocalForward 3128 127.0.0.1:3128</span><br></pre></td></tr></table></figure>

<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>when unexpected happened, use option <code>-vvv</code> to output debug message.</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server</a></li>
<li><a href="https://www.cyberciti.biz/faq/create-ssh-config-file-on-linux-unix/" target="_blank" rel="noopener">https://www.cyberciti.biz/faq/create-ssh-config-file-on-linux-unix/</a></li>
<li><a href="http://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/" target="_blank" rel="noopener">http://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/</a></li>
<li><a href="https://linux.die.net/man/5/ssh_config" target="_blank" rel="noopener">https://linux.die.net/man/5/ssh_config</a></li>
<li><a href="http://www.zsythink.net/archives/2375" target="_blank" rel="noopener">http://www.zsythink.net/archives/2375</a></li>
<li>man ssh_config</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/09/25/bresenham/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/09/25/bresenham/" class="post-title-link" itemprop="url">bresemham直线算法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-09-25 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-25T00:00:00+08:00">2017-09-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>布雷森汉姆光栅直线算法，用于计算光栅图中两点间的直线经过的点，因为其简单高效，被广泛使用。<br>在网格图中，怪物从A点移动到B点，如果允许怪物走对角线，那么最简单的移动方式就是从x，y方向上同时向目标点靠近，<br>直到其中方向距离为0，接下来从另一个方向上向目标点移动，那么表现上就是先走对角然后走直线。BTW，<code>A*</code>算法中的启发函数h，<br>在允许对角线移动的网格图中就可以用这种方法计算，称为octile算法，相比曼哈顿距离更精确，比欧氏距离更简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = max(dx, dy) + (sqrt2 - 1) * min(dx, dy)</span><br></pre></td></tr></table></figure>

<p>本文简单介绍了该算法的推导过程，并用Erlang实现了该算法。</p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>给定起始点(X0,Y0), (X1, Y1)，先考虑特殊情况，斜率范围从0到1，X0&lt;X1, Y0&lt;Y1。<br>那么x每前进1步，y前进距离为m，其中m=dy/dx， 我们用e记录y前进的累积值，x每前进1步，e=e+m。<br>当e&gt;0.5时，应当使y也前进1步，并将1从e中扣去：e=e-1。</p>
<p>概括起来就是一个判断条件，两种更新策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// e = 0;</span><br><span class="line">e = e + m;</span><br><span class="line">if (e &gt; 0.5) &#123;</span><br><span class="line">    e = e - 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    e = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了去掉除法和浮点计算，我们令<code>D = 2*dx*e - dx</code>, 带入上面的三个公式，上面的判断条件和更新策略变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// D = -Dx;</span><br><span class="line">D = D + 2*dy;</span><br><span class="line">if(D &gt; 0) &#123;</span><br><span class="line">    D = D - 2*dx</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    D = D</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始e=0, 所以D=-dx，然后每次D增加2dy，当D&gt;0时，减去2dx。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现的时候需要把特殊情况一般化。下面的代码给出了一个一般化的计算过程。首先根据轴的长短选择主轴，<br>主轴就是每次前进一个单位的轴。然后根据起点和终点的大小决定前进的方向，终点大于起点，则+1，否则-1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">plot(&#123;X0, Y0&#125;, &#123;X1, Y1&#125;) -&gt;</span><br><span class="line">    Dx = abs(X1 - X0),</span><br><span class="line">    Dy = abs(Y1 - Y0),</span><br><span class="line">    StepX = if X1 &gt; X0 -&gt; 1; true -&gt; -1 end,</span><br><span class="line">    StepY = if Y1 &gt; Y0 -&gt; 1; true -&gt; -1 end,</span><br><span class="line">    if</span><br><span class="line">        Dx &gt; Dy -&gt; plot_x(&#123;X0, Y0&#125;, &#123;X1, Y1&#125;, 2*Dx, 2*Dy, StepX, StepY, -Dx, [&#123;X0,Y0&#125;]);</span><br><span class="line">        true -&gt; plot_y(&#123;X0, Y0&#125;, &#123;X1, Y1&#125;, 2*Dx, 2*Dy, StepX, StepY, -Dy, [&#123;X0,Y0&#125;])</span><br><span class="line">    end.</span><br><span class="line"></span><br><span class="line">plot_x(&#123;X1, _&#125;, &#123;X1, _&#125;, _DeltaX, _DeltaY, _, _, _D, Path) -&gt;</span><br><span class="line">    lists:reverse(Path);</span><br><span class="line">plot_x(&#123;X0, Y0&#125;, &#123;X1, Y1&#125;, DeltaX, DeltaY, StepX, StepY, D0, Path) -&gt;</span><br><span class="line">    Nx = X0 + StepX,</span><br><span class="line">    D1 = D0 + DeltaY,</span><br><span class="line">    &#123;Ny, Nd&#125; = if</span><br><span class="line">        D1 &gt; 0 -&gt; &#123;Y0 + StepY, D1 - DeltaX&#125;;</span><br><span class="line">        true -&gt; &#123;Y0, D1&#125;</span><br><span class="line">    end,</span><br><span class="line">    plot_x(&#123;Nx, Ny&#125;, &#123;X1, Y1&#125;, DeltaX, DeltaY, StepX, StepY, Nd, [&#123;Nx, Ny&#125;|Path]).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot_y(&#123;_, Y1&#125;, &#123;_, Y1&#125;, _DeltaX, _DeltaY, _, _, _D, Path) -&gt;</span><br><span class="line">    lists:reverse(Path);</span><br><span class="line">plot_y(&#123;X0, Y0&#125;, &#123;X1, Y1&#125;, DeltaX, DeltaY, StepX, StepY, D0, Path) -&gt;</span><br><span class="line">    Ny = Y0 + StepY,</span><br><span class="line">    D1 = D0 + DeltaX,</span><br><span class="line">    &#123;Nx, Nd&#125; = if</span><br><span class="line">        D1 &gt; 0 -&gt; &#123;X0 + StepX, D1 - DeltaY&#125;;</span><br><span class="line">        true -&gt; &#123;X0, D1&#125;</span><br><span class="line">    end,</span><br><span class="line">    plot_y(&#123;Nx, Ny&#125;, &#123;X1, Y1&#125;, DeltaX, DeltaY, StepX, StepY, Nd, [&#123;Nx, Ny&#125;|Path]).</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/09/09/special-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/09/09/special-process/" class="post-title-link" itemprop="url">Erlang特殊进程</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-09T00:00:00+08:00">2017-09-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>特殊进程是通过proc_lib来启动的进程，并实现了system消息处理进程。<br>包括但不限于常用的gen_server, gen_statem, gen_event等标准Behavior。</p>
<h2 id="为啥自己实现"><a href="#为啥自己实现" class="headerlink" title="为啥自己实现"></a>为啥自己实现</h2><p>虽然Behavior很好很强大，可以满足绝大部分的需求，但是它们也存在缺点，那就是过于通用。为了达到通用的目的，<br>标准Behavior包含了大量处理边界条件的逻辑，一般情况下不会成为问题，但是当你的进程成为瓶颈的时候，可能需要考虑自己实现一个。<br>比方说：</p>
<ul>
<li>有一个supervisor进程监控大量work进程，还有另一个gen_server进程来控制work的数量，那么这两个进程有一些工作是重复的。</li>
<li>有一个gen_server只会被local进程使用到，但是他包含了大量call，那么通用的call机制可能成为瓶颈。</li>
</ul>
<h2 id="为啥不用普通进程"><a href="#为啥不用普通进程" class="headerlink" title="为啥不用普通进程"></a>为啥不用普通进程</h2><p>除了一些需要异步进行的临时任务，尽量不要使用普通进程。特殊进程可以为你提供：</p>
<ul>
<li>告诉你哪个进程是它的父进程</li>
<li>父进程退出时优雅的退出</li>
<li>异常退出时生成log</li>
<li>能够查看或者替换进程状态</li>
</ul>
<p>这些好处值得多花几分钟来实现。</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>特殊进程必须通过proc_lib和sys来实现。</p>
<h3 id="proc-lib"><a href="#proc-lib" class="headerlink" title="proc_lib"></a>proc_lib</h3><p>通过proc_lib启动的进程总是会把两个信息写入进程字典：</p>
<ul>
<li>$ancestors</li>
<li>$initial_call</li>
</ul>
<p>这两个信息被各种调试工具用到。如果开启了SASL，那么proc_lib启动的进程崩溃的时候会生成崩溃日志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ erl -boot start_sasl</span><br><span class="line">...</span><br><span class="line">1&gt; proc_lib:spawn_link(fun() -&gt; 1 = 2 end).</span><br><span class="line">=CRASH REPORT==== 8-Sep-2017::17:05:42 ===</span><br><span class="line">  crasher:</span><br><span class="line">    initial call: erl_eval:-expr/5-fun-1-/0</span><br><span class="line">    pid: &lt;0.43.0&gt;</span><br><span class="line">    registered_name: []</span><br><span class="line">    exception error: no match of right hand side value 2</span><br><span class="line">    ancestors: [&lt;0.41.0&gt;]</span><br><span class="line">    messages: []</span><br><span class="line">    links: [&lt;0.41.0&gt;]</span><br><span class="line">    dictionary: []</span><br><span class="line">    trap_exit: false</span><br><span class="line">    status: running</span><br><span class="line">    heap_size: 233</span><br><span class="line">    stack_size: 27</span><br><span class="line">    reductions: 97</span><br><span class="line">  neighbours:</span><br><span class="line">    neighbour: [&#123;pid,&lt;0.41.0&gt;&#125;,</span><br><span class="line">                  &#123;registered_name,[]&#125;,</span><br><span class="line">                  &#123;initial_call,&#123;erlang,apply,2&#125;&#125;,</span><br><span class="line">                  &#123;current_function,&#123;io,wait_io_mon_reply,2&#125;&#125;,</span><br><span class="line">                  &#123;ancestors,[]&#125;,</span><br><span class="line">                  &#123;messages,[]&#125;,</span><br><span class="line">                  &#123;links,[&lt;0.26.0&gt;,&lt;0.43.0&gt;]&#125;,</span><br><span class="line">                  &#123;dictionary,[]&#125;,</span><br><span class="line">                  &#123;trap_exit,false&#125;,</span><br><span class="line">                  &#123;status,waiting&#125;,</span><br><span class="line">                  &#123;heap_size,610&#125;,</span><br><span class="line">                  &#123;stack_size,29&#125;,</span><br><span class="line">                  &#123;reductions,1161&#125;]</span><br><span class="line">** exception exit: &#123;badmatch,2&#125;</span><br></pre></td></tr></table></figure>

<p>从上面log可以看到父进程以及初始函数都出现在崩溃日志中。<br>最后，用pro_lib还提供一个可选的特征，使用确认函数来同步启动进程。</p>
<h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>通过proc_lib启动的进程必须实现sys协议。<br>sys能够为你的进程带来更多调试以及跟踪机制。</p>
<ul>
<li>sys:get_status/1</li>
<li>sys:get_state/1</li>
<li>sys:replace_state/2</li>
</ul>
<p>除此之外，实现sys协议的进程还能够暂停以及恢复。</p>
<h3 id="异步启动"><a href="#异步启动" class="headerlink" title="异步启动"></a>异步启动</h3><ul>
<li>通过proc_lib:spawn_link/1..4或者proc_lib:spawn_opt/2..5启动进程。</li>
<li>写一个receive的循环。</li>
<li>父进程退出时退出，这意味着如果trap exit消息，需要处理父进程退出消息。</li>
<li>处理系统消息。</li>
<li>实现system_continue/3, system_terminate/4, system_code_change/4回调函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">start_link() -&gt;</span><br><span class="line">    proc_lib:spawn_link(?MODULE, init, [self()]).</span><br><span class="line">init(Parent) -&gt;</span><br><span class="line">    loop(Parent).</span><br><span class="line">loop(Parent) -&gt;</span><br><span class="line">    receive</span><br><span class="line">        %% Only required when trap_exit is enabled.</span><br><span class="line">        &#123;’EXIT’, Parent, Reason&#125; -&gt;</span><br><span class="line">            terminate(State, Reason, NbChildren);</span><br><span class="line">        &#123;system, From, Request&#125; -&gt;</span><br><span class="line">            sys:handle_system_msg(Request, From, Parent, ?MODULE, [], &#123;state, Parent&#125;);</span><br><span class="line">        Msg -&gt;</span><br><span class="line">            error_logger:error_msg(&quot;Unexpected message ~p~n&quot;, [Msg]),</span><br><span class="line">            loop(Parent)</span><br><span class="line">    end.</span><br><span class="line">system_continue(_, _, &#123;state, Parent&#125;) -&gt;</span><br><span class="line">    loop(Parent).</span><br><span class="line">system_terminate(Reason, _, _, _) -&gt;</span><br><span class="line">    exit(Reason).</span><br><span class="line">system_code_change(Misc, _, _, _) -&gt;</span><br><span class="line">    &#123;ok, Misc&#125;.</span><br></pre></td></tr></table></figure>

<h3 id="同步启动"><a href="#同步启动" class="headerlink" title="同步启动"></a>同步启动</h3><ul>
<li>使用proc_lib:start_link/1..4启动进程</li>
<li>在进入循环之前调用proc_lib:init_ack/1</li>
<li>其他跟异步启动类似</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">start_link() -&gt;</span><br><span class="line">    proc_lib:start_link(?MODULE, init, [self()]).</span><br><span class="line">init(Parent) -&gt;</span><br><span class="line">    ok = proc_lib:init_ack(Parent, &#123;ok, self()&#125;),</span><br><span class="line">    loop(Parent).</span><br><span class="line">loop(Parent) -&gt;</span><br><span class="line">    receive</span><br><span class="line">        %% Only required when trap_exit is enabled.</span><br><span class="line">        &#123;’EXIT’, Parent, Reason&#125; -&gt;</span><br><span class="line">            terminate(State, Reason, NbChildren);</span><br><span class="line">        &#123;system, From, Request&#125; -&gt;</span><br><span class="line">            sys:handle_system_msg(Request, From, Parent, ?MODULE, [],</span><br><span class="line">                                  &#123;state, Parent&#125;);</span><br><span class="line">        Msg -&gt;</span><br><span class="line">            error_logger:error_msg(&quot;Unexpected message ~p~n&quot;, [Msg]),</span><br><span class="line">            loop(Parent)</span><br><span class="line">    end.</span><br><span class="line">system_continue(_, _, &#123;state, Parent&#125;) -&gt;</span><br><span class="line">    loop(Parent).</span><br><span class="line">system_terminate(Reason, _, _, _) -&gt;</span><br><span class="line">    exit(Reason).</span><br><span class="line">system_code_change(Misc, _, _, _) -&gt;</span><br><span class="line">    &#123;ok, Misc&#125;.</span><br></pre></td></tr></table></figure>

<h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><p>OTP的call实现考虑了很多特殊情况，整个实现非常复杂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">do_call(Process, Label, Request, Timeout) -&gt;</span><br><span class="line">    try erlang:monitor(process, Process) of</span><br><span class="line">	Mref -&gt;</span><br><span class="line">	    %% If the monitor/2 call failed to set up a connection to a</span><br><span class="line">	    %% remote node, we don&apos;t want the &apos;!&apos; operator to attempt</span><br><span class="line">	    %% to set up the connection again. (If the monitor/2 call</span><br><span class="line">	    %% failed due to an expired timeout, &apos;!&apos; too would probably</span><br><span class="line">	    %% have to wait for the timeout to expire.) Therefore,</span><br><span class="line">	    %% use erlang:send/3 with the &apos;noconnect&apos; option so that it</span><br><span class="line">	    %% will fail immediately if there is no connection to the</span><br><span class="line">	    %% remote node.</span><br><span class="line"></span><br><span class="line">	    catch erlang:send(Process, &#123;Label, &#123;self(), Mref&#125;, Request&#125;,</span><br><span class="line">		  [noconnect]),</span><br><span class="line">	    receive</span><br><span class="line">		&#123;Mref, Reply&#125; -&gt;</span><br><span class="line">		    erlang:demonitor(Mref, [flush]),</span><br><span class="line">		    &#123;ok, Reply&#125;;</span><br><span class="line">		&#123;&apos;DOWN&apos;, Mref, _, _, noconnection&#125; -&gt;</span><br><span class="line">		    Node = get_node(Process),</span><br><span class="line">		    exit(&#123;nodedown, Node&#125;);</span><br><span class="line">		&#123;&apos;DOWN&apos;, Mref, _, _, Reason&#125; -&gt;</span><br><span class="line">		    exit(Reason)</span><br><span class="line">	    after Timeout -&gt;</span><br><span class="line">		    erlang:demonitor(Mref, [flush]),</span><br><span class="line">		    exit(timeout)</span><br><span class="line">	    end</span><br><span class="line">    catch</span><br><span class="line">	error:_ -&gt;</span><br><span class="line">	    %% Node (C/Java?) is not supporting the monitor.</span><br><span class="line">	    %% The other possible case -- this node is not distributed</span><br><span class="line">	    %% -- should have been handled earlier.</span><br><span class="line">	    %% Do the best possible with monitor_node/2.</span><br><span class="line">	    %% This code may hang indefinitely if the Process</span><br><span class="line">	    %% does not exist. It is only used for featureweak remote nodes.</span><br><span class="line">	    Node = get_node(Process),</span><br><span class="line">	    monitor_node(Node, true),</span><br><span class="line">	    receive</span><br><span class="line">		&#123;nodedown, Node&#125; -&gt;</span><br><span class="line">		    monitor_node(Node, false),</span><br><span class="line">		    exit(&#123;nodedown, Node&#125;)</span><br><span class="line">	    after 0 -&gt;</span><br><span class="line">		    Tag = make_ref(),</span><br><span class="line">		    Process ! &#123;Label, &#123;self(), Tag&#125;, Request&#125;,</span><br><span class="line">		    wait_resp(Node, Tag, Timeout)</span><br><span class="line">	    end</span><br><span class="line">    end.</span><br></pre></td></tr></table></figure>

<p>我们自己实现的时候可以去掉那些特殊情况，针对我们自己的情况优化冗余的检查和逻辑。<br>比如，我们没有注册名字，就不需要解析名字；如果没有用到C或者Java节点，可以去掉处理这部分的代码。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>参考ranch的ranch_conns_sup模块。很经典的例子。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://ninenines.eu/res/erlanger-preview.pdf" target="_blank" rel="noopener">The Erlanger Handbook</a></li>
<li>Ranch</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/09/07/ranch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/09/07/ranch/" class="post-title-link" itemprop="url">Ranch源码分析</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-09-07 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-07T00:00:00+08:00">2017-09-07</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Ranch是一个TCP连接管理开源库，从著名的cowboy开源库中剥离出来的。<br>本文对ranch的重要模块一一进行解读，来品味一下这个优雅小巧而又功能强大的TCP管理库。<br>本文基于ranch的1.0版本。</p>
<h2 id="ranch"><a href="#ranch" class="headerlink" title="ranch"></a>ranch</h2><p>提供对外接口。最重要的接口是start_listener和stop_listener。需要指定一个唯一的名字Ref，<br>socket处理模块以及参数，协议处理回调模块及参数。这个函数会将整个监控树启动起来。<br>Ref是负责处理这个端口连接的监控树的名字，有了这个名字就可以对这颗监控树执行一些操作，<br>比方说停止监听端口、设置连接上限等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_listener(Ref, NbAcceptors, Transport, TransOpts, Protocol, ProtoOpts) -&gt; &#123;ok, Pid&#125; | &#123;error, badarg&#125;</span><br><span class="line">stop_listener(Ref) -&gt; ok | &#123;error, not_found&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ranch-sup"><a href="#ranch-sup" class="headerlink" title="ranch_sup"></a>ranch_sup</h2><p>根监控树。启动ranch_server进程以及ranch_listener_sup监控树。<br>其中ranch_server是启动application的时候就会启动，而ranch_listener_sup则是开始监听的时候动态启动的。<br>启动ranch_listener_sup需要提供各种参数，而且支持启动多个实例。</p>
<h2 id="ranch-server"><a href="#ranch-server" class="headerlink" title="ranch_server"></a>ranch_server</h2><p>是个打杂的进程，主要提供一些获取、修改参数的接口。主要数据都保存在ranch_server这个ets表中。<br>进程重启的时候也会ets表中恢复出进程状态。所以这个ets表的宿主进程并不是这个进程本身，而是ranch_sup。<br>即使这个进程崩溃，也不会丢失ets表的数据。</p>
<ul>
<li>{max_conns, Ref}: MaxConns</li>
<li>{opts, Ref}: Opts</li>
<li>{conns_sup, Ref}: Pid</li>
<li>{addr, Ref}: Addr</li>
</ul>
<h2 id="ranch-listener-sup"><a href="#ranch-listener-sup" class="headerlink" title="ranch_listener_sup"></a>ranch_listener_sup</h2><p>监控进程，负责启动ranch_conns_sup以及ranch_acceptors_sup两个监控树。<br>因为没有注册名字，ranch_listener_sup监控树可以启动多个实例，一般来说，每一个监听的端口对应一个监控树。<br>这些监控树都挂在ranch_sup下面。</p>
<h2 id="ranch-acceptors-sup"><a href="#ranch-acceptors-sup" class="headerlink" title="ranch_acceptors_sup"></a>ranch_acceptors_sup</h2><p>也是监控树，开始监听端口，并启动NbAcceptors个数的accept进程来接收socket接请求。<br>这个进程拥有监听socket的所有权。</p>
<h2 id="ranch-transport"><a href="#ranch-transport" class="headerlink" title="ranch_transport"></a>ranch_transport</h2><p>定义操作socket的接口。如listen,accept,recv,send,shutdown,close等。<br>ranch实现了两个数据传输协议，tcp和ssl。分别由ranch_tcp和ranch_ssl实现。<br>可以这么理解，在面向对象世界里，ranch_transport对应接口，ranch_tcp和ranch_ssl对应接口的具体实现。</p>
<h2 id="ranch-tcp"><a href="#ranch-tcp" class="headerlink" title="ranch_tcp"></a>ranch_tcp</h2><p>实现ranch_transport定义的接口，主要是封装了gen_tcp的一些基本操作。<br>监听socket的属性分类两类，一类是可以设置的，一类是默认的。</p>
<ul>
<li>可设置的包括：backlog,ip,linger,nodelay,port,raw,send_timeout,send_timeout_close</li>
<li>默认的包括：binary,{active,false},{packet,raw},{reuseaddr,true},{nodelay,true}</li>
</ul>
<p>可以看出，binary,{active,false},{packet,raw},{reuseaddr,true}这几个是写死了无法通过传入参数来改变的。</p>
<h2 id="ranch-ssl"><a href="#ranch-ssl" class="headerlink" title="ranch_ssl"></a>ranch_ssl</h2><p>实现ranch_transport定义的接口，主要是封装了ssl的一些基本操作。</p>
<h2 id="ranch-acceptor"><a href="#ranch-acceptor" class="headerlink" title="ranch_acceptor"></a>ranch_acceptor</h2><p>ranch_accept接收到连接请求以后，将socket控制权转交ranch_conns_sup，<br>同时通知ranch_conns_sup启动连接处理进程，处理此socket的数据收发。<br>ranch_conns_sup启动连接进程以后，accept进程继续accept新的连接。如果由于某些原因（比如连接数达到上限）<br>连接进程没有启动起来，那么accept进程就会阻塞在这里，无法继续接收连接，直到连接进程启动起来为止。<br>如果系统文件句柄消耗完毕，accept进程会等待100ms才继续接收连接请求。<br>如果监听socket关闭了，那么accpet进程会因为匹配不到消息崩溃退出。<br>因为监听socket使用了active,false选项，在socket的宿主进程主动recv之前，宿主进程不会收到来自socket的数据。<br>所以accept进程以及随后的ranch_conns_sup进程都不会收到socket的数据，从而保证连接进程接收到的数据是完整的。<br>不过为了防止意外情况（比如socket用了active其他选项）导致accpet进程收到了其他消息，<br>accpet进程会在进入下一次accpet前清空一下消息队列。</p>
<h2 id="ranch-conns-sup"><a href="#ranch-conns-sup" class="headerlink" title="ranch_conns_sup"></a>ranch_conns_sup</h2><p>连接进程的管理进程，负责连接进程的启动。作为ranch_listener_sup的子进程之一，这个进程启动时会想ranch_server注册自己。<br>这样后续启动的ranch_acceptors_sup就能拿到连接管理进程，可以作为参数传递给ranch_acceptor进程，以便后者收到连接请求是启动连接进程。<br>这是一个特殊进程，也就是用proc_lib来启动的进程，并且会处理system消息，这个进程同时具有gen_server和supervisor的功能。<br>在作者的书&lt;<the erlanger playbook>&gt;中第一章就讲到了特殊进程，以及为什么我们要用特殊进程。这个进程就是一个非常好的例子。</the></p>
<p>这个进程收到socket发送的启动连接进程消息以后，启动连接进程，将socket控制权转交连接进程，并通知连接进程开始进行数据收发。</p>
<p>此进程会将连接进程Pid存入进程字典，并维护连接进程的数量。<br>如果数量达到上限，则暂时不回复accept进程，而是将accept进程存入Sleeper列表中。这将导致accept进程阻塞在receive语句中，<br>无法继续accept连接。如果还没有到上限，则立即回复accept进程，accept进程收到回复就可以继续accpet连接了。<br>所以达到配置的连接数量上限以后，实际上我们的还能创建NbAcceptors个连接进程，然后所有accept进程都阻塞在receive过程，<br>不会继续接收socket连接。</p>
<p>如果启动连接进程失败了，那么这个进程需要回复accpet进程，防止accept阻塞在receive语句，同时关闭socket连接，并打印错误日志。</p>
<p>这个进程trap_exit标记值为true，连接进程通过start_link创建，所以当连接进程正常或者异常退出时，<br>这个进程能收到<code>{&#39;EXIT&#39;,Pid,Reason}</code>消息，方便我们维护连接子进程。<br>这时候如果还有阻塞的accept进程即Sleeper，则会取出一个来回复，然后这个accpet进程就能继续接收连接请求了。</p>
<p>ranch_conns_sup进程是作为ranch_listener_sup监控下的进程启动的，而且它启动的type是supervisor。<br>所以他需要向它的父进程提供supervisor的功能，主要是以下几点：</p>
<ul>
<li>which_children</li>
<li>count_children</li>
<li>shutdown子进程。包括强制退出，以及等待超时退出。父进程退出时，或者系统退出时，等待通知子进程退出，超时后强制kill子进程。</li>
</ul>
<p>不过它并不需要向子进程提供supervisor功能，就算子进程异常退出，它也不会尝试重启子进程，因为没有这个必要。<br>关闭子进程时，先monitor，再unlink，再调用exit发退出消息。先unlink是防止子进程退出时又一次收到EXIT消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">terminate(#state&#123;shutdown=brutal_kill&#125;, Reason, _) -&gt;</span><br><span class="line">	Pids = get_keys(true),</span><br><span class="line">	_ = [begin</span><br><span class="line">		unlink(P),</span><br><span class="line">		exit(P, kill)</span><br><span class="line">	end || P &lt;- Pids],</span><br><span class="line">	exit(Reason);</span><br><span class="line">terminate(#state&#123;shutdown=Shutdown&#125;, Reason, NbChildren) -&gt;</span><br><span class="line">	shutdown_children(),</span><br><span class="line">	_ = if</span><br><span class="line">		Shutdown =:= infinity -&gt;</span><br><span class="line">			ok;</span><br><span class="line">		true -&gt;</span><br><span class="line">			erlang:send_after(Shutdown, self(), kill)</span><br><span class="line">	end,</span><br><span class="line">	wait_children(NbChildren),</span><br><span class="line">	exit(Reason).</span><br><span class="line"></span><br><span class="line">shutdown_children() -&gt;</span><br><span class="line">	Pids = get_keys(true),</span><br><span class="line">	_ = [begin</span><br><span class="line">		monitor(process, P),</span><br><span class="line">		unlink(P),</span><br><span class="line">		exit(P, shutdown)</span><br><span class="line">	end || P &lt;- Pids],</span><br><span class="line">	ok.</span><br><span class="line"></span><br><span class="line">wait_children(0) -&gt;</span><br><span class="line">	ok;</span><br><span class="line">wait_children(NbChildren) -&gt;</span><br><span class="line">	receive</span><br><span class="line">        &#123;&apos;DOWN&apos;, _, process, Pid, _&#125; -&gt;</span><br><span class="line">			_ = erase(Pid),</span><br><span class="line">			wait_children(NbChildren - 1);</span><br><span class="line">		kill -&gt;</span><br><span class="line">			Pids = get_keys(true),</span><br><span class="line">			_ = [exit(P, kill) || P &lt;- Pids],</span><br><span class="line">			ok</span><br><span class="line">	end.</span><br></pre></td></tr></table></figure>

<p>值得一提的还有子进程的存储方式，这里使用了进程字典的get_keys接口来获取所有子进程。如果shutdown指定了超时时间，<br>那么就会通过一个定时器来触发kill消息，将所有尚未退出的子进程调用<code>exit(Pid, kill)</code>强行退出。</p>
<h2 id="连接进程-ranch-protocol的具体实现"><a href="#连接进程-ranch-protocol的具体实现" class="headerlink" title="连接进程(ranch_protocol的具体实现)"></a>连接进程(ranch_protocol的具体实现)</h2><p>ranch_protocol定义了启动连接进程的接口。只有一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_link(Ref, Socket, Transport, ProtocolOptions) -&gt; &#123;ok, Pid&#125;</span><br></pre></td></tr></table></figure>

<p>实现这个接口的模块用来处理建立连接以后的数据收发，start_link函数创建一个进程用来处理协议数据。<br>注意这里只能是start_link，意味着父进程（即ranch_conns_sup进程）和创建的进程之间有link的关系。<br>这个要求跟supervisor要求子进程创建函数必须是start_link是一致的。<br>因为supervisor进程就是依靠link关系来管理子进程的。</p>
<p>父进程ranch_conns_sup借助link关系来监控连接进程的退出状态，借此维护连接的数量，然而并不会重启子进程。</p>
<p>Ranch并没有提供这个模块的默认实现。我们利用ranch实现自己功能的时候，首先就需要实现这个接口，来处理数据收发的逻辑。<br>然后将其作为参数传入启动监听过程的函数中，即start_listener中的Protocol参数。</p>
<p>这里就是我们要实现的逻辑所在了。首先要实现ranch_protocol的start_link/4接口，以便ranch_conns_sup调用。<br>通常这里都是spwan_link一个进程出来，返回。在进程进入循环之前调用<code>ranch:accept_ack(Ref)</code>等待ranch_conns_sup通知我们，<br>socket已经转移控制权，然后就可以进入循环进行消息接收和处理了。</p>
<p>如果要用gen_server来实现连接进程，我们就要注意了。因为我们需要先返回{ok, Pid}到ranch_conns_sup进程，<br>然后等待ranch_conns_sup进程给我们发消息，通知我们shoot，才能进入消息循环。<br>（这是因为连接进程的消息循环一般会将socket的active由false改成once，如果ranch_conns_sup还没有将控制权转交过来就调用了set_opts,<br>那么ranch_conns_sup就可能会收到来自socket的消息。所以我们需要确保已经转移了控制权才能够进入消息循环。<a href="http://santtu.iki.fi/2014/03/06/network-and-parallelism-in-erlang" target="_blank" rel="noopener">参考</a>）<br>如果我们直接用gen_server:start_link来启动这个连接进程，<br>就会出现了一个困境：首先，ranch_conns_sup需要start_link返回Pid以后才能通知连接进程就绪，而连接进程需要接收到通知才能从init中返回。<br>这样就出现死锁了。解决的方法主要有两种：</p>
<ul>
<li><p>一种是在主循环来接收shoot消息，比如init返回一个{ok, Pid, 0}，那么进入循环后第一条处理的就是handle_info(timeout),<br>我们可以在这里接收shoot消息，设置socket选项等。</p>
</li>
<li><p>要么使用其他proc_lib方法来启动进程，比如proc_lib:start_link/3，然后在初始化的时候直接通过<br>proc_lib:init_ack({ok, self()})来向父进程返回Pid，然后等待父进程的shoot消息。</p>
</li>
</ul>
<p>个人更倾向于第二种方式。因为shoot消息是一次性的，更适合在初始化的时候搞定，而不是放在主循环里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start_link(Ref, Socket, Transport, Opts) -&gt;</span><br><span class="line">	proc_lib:start_link(?MODULE, init, [Ref, Socket, Transport, Opts]).</span><br><span class="line"></span><br><span class="line">init(Ref, Socket, Transport, _Opts = []) -&gt;</span><br><span class="line">	ok = proc_lib:init_ack(&#123;ok, self()&#125;),</span><br><span class="line">	ok = ranch:accept_ack(Ref),</span><br><span class="line">	ok = Transport:setopts(Socket, [&#123;active, once&#125;]),</span><br><span class="line">	gen_server:enter_loop(?MODULE, [],</span><br><span class="line">		#state&#123;socket=Socket, transport=Transport&#125;,</span><br><span class="line">		?TIMEOUT).</span><br></pre></td></tr></table></figure>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><a href="https://github.com/ninenines/ranch" target="_blank" rel="noopener">https://github.com/ninenines/ranch</a></li>
<li><a href="https://git.ninenines.eu/ranch.git/plain/CHANGELOG.asciidoc" target="_blank" rel="noopener">https://git.ninenines.eu/ranch.git/plain/CHANGELOG.asciidoc</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Deng</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Deng</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>

<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
