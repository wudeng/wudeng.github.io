<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Deng 的梦呓">
<meta property="og:url" content="http://wudeng.github.io/page/2/index.html">
<meta property="og:site_name" content="Deng 的梦呓">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Deng 的梦呓">
  <link rel="canonical" href="http://wudeng.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Deng 的梦呓</title>
  <meta name="generator" content="Hexo 3.9.0">
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?356ed3e5db3bc7eda8ce3e7833731107";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Deng 的梦呓</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/09/06/device-wake-up-computer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/09/06/device-wake-up-computer/" class="post-title-link" itemprop="url">Windows自动唤醒问题</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-09-06 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-06T00:00:00+08:00">2017-09-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>早上到公司发现电脑是开着的，记得下班的时候是休眠的，为什么自己开了呢。打开事件查看器，发现了问题所在。</p>
<p><img src="event_wake_up.png" alt="event_wake_up"></p>
<p>电脑只休眠了不到一个小时就自动唤醒了(好像暴露了加班狗的属性)。</p>
<p>事件查看器显示唤醒电脑的是音频设备。估计跟电脑开着音乐有关系。</p>
<p><img src="event_wake_up2.png" alt="event_wake_up"></p>
<p>网上搜了下解决方案，有说从设备管理器就可以禁掉设备自动唤醒电脑，但是我从设备管理器并没有找到这个电源管理的选项。</p>
<p>不过也有第二种方案，直接通过命令行来禁止。首先列出支持唤醒电脑的设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\playerground&gt;powercfg -devicequery wake_armed</span><br><span class="line">HID-compliant mouse (001)</span><br><span class="line">Realtek PCIe GBE Family Controller</span><br><span class="line">HID Keyboard Device</span><br></pre></td></tr></table></figure>

<p>果然发现了肇事者。果断禁掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\playerground&gt;powercfg -devicedisablewake &quot;Realtek PCIe GBE Family Controller&quot;</span><br></pre></td></tr></table></figure>

<p>再列举一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\playerground&gt;powercfg -devicequery wake_armed</span><br><span class="line">HID-compliant mouse (001)</span><br><span class="line">HID Keyboard Device</span><br></pre></td></tr></table></figure>

<p>发现音频设备不见了，问题解决。要把它加回来也容易，把disable改成enable就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\playerground&gt;powercfg -deviceenablewake &quot;Realtek PCIe GBE Family Controller&quot;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://www.sevenforums.com/tutorials/122027-devices-allow-prevent-wake-up-computer.html" target="_blank" rel="noopener">https://www.sevenforums.com/tutorials/122027-devices-allow-prevent-wake-up-computer.html</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/09/01/monster-steering-behavior/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/09/01/monster-steering-behavior/" class="post-title-link" itemprop="url">怪物包围算法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-09-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-01T00:00:00+08:00">2017-09-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ARPG游戏中经常出现多个怪物追着玩家跑的情况，如果怪物始终瞄着玩家的位置移动，那么很容易就出现怪物扎堆的情况。<br>本文探讨并实现了一个位置管理算法，来解决这个问题。</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>我们的思路是：如果玩家已经在攻击范围内，直接攻击。否则怪物向玩家移动，形成一个以攻击距离为半径，玩家为圆心的包围圈。<br>在移动过程中，怪物优先选择怪物所在位置与玩家连线跟圆的交点。 如果交点被占据，则向两边搜索新的位置，直到找到一个位置为止。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>整个圆是360度，我们把它等分为18个区间，每个区间20度，18个区间基本足以满足对怪物数量的要求了。<br>我们首先找到怪物相对玩家位置的角度。</p>
<p><code>CurAngle = (math:atan2(Z1 - Z0, X1 - X0) / math:pi()) + 180</code></p>
<p>atan2求出的范围是弧度(-pi, pi]，我们需要将其转换为(0, 360]的角度。<br>然后检查是否当前角度所在的区间是否已经被占用，由于区间是一个连续的范围，我们用起点来表示一个区间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-define(SLICE, 20). %% 极坐标20度为一个slot分布怪物</span><br><span class="line"></span><br><span class="line">find_angle(PlayerId, PlayerPos, Angle) -&gt;</span><br><span class="line">    PlayerPos0 = get(&#123;player_pos, PlayerId&#125;),</span><br><span class="line">    PlayerPos0 /= PlayerPos andalso</span><br><span class="line">    begin</span><br><span class="line">        erase(&#123;angle, PlayerId&#125;),</span><br><span class="line">        put(&#123;player_pos, PlayerId&#125;, PlayerPos),</span><br><span class="line">        ?INFO(&quot;~p change pos ~p&quot;, [PlayerId, PlayerPos])</span><br><span class="line">    end,</span><br><span class="line">    AdjustAngle = (Angle div ?SLICE) * ?SLICE,</span><br><span class="line">    Angles = occupied_angle(PlayerId),</span><br><span class="line">    TheAngle =</span><br><span class="line">    case lists:member(AdjustAngle, Angles) of</span><br><span class="line">        true -&gt;</span><br><span class="line">            find_angle1(AdjustAngle, ?SLICE, Angles);</span><br><span class="line">        false -&gt;</span><br><span class="line">            AdjustAngle</span><br><span class="line">    end,</span><br><span class="line">    put(&#123;angle, PlayerId&#125;, [TheAngle|Angles]),</span><br><span class="line">    lib_common:random_n(TheAngle, TheAngle + ?SLICE - 1) rem 360.</span><br><span class="line"></span><br><span class="line">occupied_angle(PlayerId) -&gt;</span><br><span class="line">    case get(&#123;angle, PlayerId&#125;) of</span><br><span class="line">        undefined -&gt; [];</span><br><span class="line">        List -&gt; List</span><br><span class="line">    end.</span><br></pre></td></tr></table></figure>

<p>如果当前区间已经被占用，则向两边搜索可用的区间。<br>我们维护一个Delta差值，逐步增大Delta，向外扩张来搜索新的区间，直到找到为止。之所以限制Delta的范围是不想让怪物越过玩家，<br>所以如果所有怪都是从同一个方向向玩家移动的时候会形成一个接近半圆的包围圈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">find_angle1(AdjustAngle, Delta, _Angles) when Delta &gt; 100 -&gt;</span><br><span class="line">    AdjustAngle;</span><br><span class="line">find_angle1(AdjustAngle, Delta, Angles) -&gt;</span><br><span class="line">    Angle1 = (AdjustAngle + Delta) rem 360,</span><br><span class="line">    case lists:member(Angle1, Angles) of</span><br><span class="line">        true -&gt;</span><br><span class="line">            Angle2 = (AdjustAngle - Delta + 360) rem 360,</span><br><span class="line">            case lists:member(Angle2, Angles) of</span><br><span class="line">                true -&gt;</span><br><span class="line">                    find_angle1(AdjustAngle, Delta+?SLICE, Angles);</span><br><span class="line">                false -&gt;</span><br><span class="line">                    Angle2</span><br><span class="line">            end;</span><br><span class="line">        false -&gt;</span><br><span class="line">            Angle1</span><br><span class="line">    end.</span><br></pre></td></tr></table></figure>

<p>解决了怪物分布的问题，还有一个问题就是玩家位置的维护。因为玩家是一直移动的，而且移动的频率很高。<br>如果每次玩家移动了以后，都清除掉老的区间，重新计算新的区间。代价会比较大，而且也不是很有必要。<br>所以我们只会在玩家离开一段距离导致目标点无法攻击玩家的时候，才更新圆心的位置，所以实际上圆心的位置跟玩家的位置可能存在一定的偏移，<br>这一点我们是可以容忍的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TargetPos = if</span><br><span class="line">    TP =:= undefined -&gt;</span><br><span class="line">        get_target_pos(PlayerId, MonsterId, PlayerPos, Distance);</span><br><span class="line">    true -&gt;</span><br><span class="line">        %% 玩家离开一段距离了，导致目标点无法攻击玩家，则更新目标点</span><br><span class="line">        Dis2 = lib_map_util:calc_dis2(TP, PlayerPos),</span><br><span class="line">        if</span><br><span class="line">            Dis2 =&lt; Distance * Distance + ?EPSILON2 -&gt; TP;</span><br><span class="line">            true -&gt; get_target_pos(PlayerId, MonsterId, PlayerPos, Distance)</span><br><span class="line">        end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>TP是老的怪物目标点，如果我们发现怪物的目标点无法攻击到玩家，则更新目标点。这里比较距离的时候还有个坑，<br>浮点数的精度有限，所以我们需要加入一个误差，<code>EPSILON2</code>。否则计算出来的目标点有可能会无法满足不等式而导致怪物在玩家周围做小步调整来切换目标点。</p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="monster_around.png" alt="monster_around"></p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>streering behaviour<br>RVO2<br>    ORCA: Optimal Reciprocal Collision Avoidance<br>    <a href="https://github.com/snape/RVO2" target="_blank" rel="noopener">https://github.com/snape/RVO2</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/08/26/erlang-memory-management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/08/26/erlang-memory-management/" class="post-title-link" itemprop="url">Erlang Memory Management</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-08-26 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-26T00:00:00+08:00">2017-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>系统自带的分配器存在的缺点：</p>
<ul>
<li>小内存分配效率低。</li>
<li>所有数据同样的分配策略，增加碎片。</li>
<li>缺乏跨平台细粒度的统计</li>
<li><code>+Mea</code> disable erts allocators and use malloc for everything</li>
<li>多核内存管理更加重要也更加复杂</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>Block: 虚拟机请求的一块内存区域。</li>
<li>Carrier: 包含一个或多个Block的内存区域，分为sbc，mbc。正常情况下大部分数据位于mbc。<ul>
<li>Single Block Carrier sbc<ul>
<li>大的block进入sbc</li>
<li><code>+M&lt;S&gt;sbct</code> 默认512k</li>
<li>可以通过erlang:system_info(allocator)查看各个allocator的配置参数</li>
</ul>
</li>
<li>Multiblock Carrier mbc<ul>
<li><code>+M&lt;S&gt;smbcs</code> smallest Multiblock carrier size</li>
<li><code>+M&lt;S&gt;lmbcs</code> largest multiblock Carrier size</li>
<li><code>+M&lt;S&gt;mbcgs</code> multiblock Carrier grow stage</li>
<li>如果增加sbct一般也会相应增大smbcs和lmbcs</li>
</ul>
</li>
<li>通过mseg_alloc分配的mbc的大小<ul>
<li>smbcs+nc*(lmbcs-smbcs)/mbcgs (nc &lt;= mbcgs)</li>
<li>lmbcs (nc &gt; mbcgs)</li>
</ul>
</li>
<li>通过sys_alloc分配的mbc<ul>
<li>least number of multiple of ycs satisfying the request</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="各种分配器"><a href="#各种分配器" class="headerlink" title="各种分配器"></a>各种分配器</h2><p><img src="memory_allocators.png" alt="memory_allocators"></p>
<p>文件erl_alloc.types中列举了所有的分配器类型以及不同数据对应的分配器类型。<br>ERTS中一共定义了11中不同的分配器，包括最基本的sys_alloc以及mseg_alloc。<br>详情见下表。Flag是启动ERTS时修改分配器配置参数的标志。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>C-name</th>
<th>Type-name</th>
<th>Flag</th>
</tr>
</thead>
<tbody><tr>
<td>Basic allocator</td>
<td>malloc interface</td>
<td>sys_alloc</td>
<td>SYSTEM</td>
<td>Y</td>
</tr>
<tr>
<td>Memory segment allocator</td>
<td>mmap interface</td>
<td>mseg_alloc</td>
<td>-</td>
<td>M</td>
</tr>
<tr>
<td>Temporary allocator</td>
<td>Temporary allocations</td>
<td>temp_alloc</td>
<td>TEMPORARY</td>
<td>T</td>
</tr>
<tr>
<td>Heap allocator</td>
<td>Erlang heap data</td>
<td>eheap_alloc</td>
<td>EHEAP</td>
<td>H</td>
</tr>
<tr>
<td>Binary allocator</td>
<td>Binary data</td>
<td>binary_alloc</td>
<td>BINARY</td>
<td>B</td>
</tr>
<tr>
<td>ETS allocator</td>
<td>ETS data</td>
<td>ets_alloc</td>
<td>ETS</td>
<td>E</td>
</tr>
<tr>
<td>Driver allocator</td>
<td>Driver data</td>
<td>driver_alloc</td>
<td>DRIVER</td>
<td>R</td>
</tr>
<tr>
<td>Short lived allocator</td>
<td>Short lived memory</td>
<td>sl_alloc</td>
<td>SHORT_LIVED</td>
<td>S</td>
</tr>
<tr>
<td>Long lived allocator</td>
<td>Long lived memory</td>
<td>ll_alloc</td>
<td>LONG_LIVED</td>
<td>L</td>
</tr>
<tr>
<td>Fiexed allocator</td>
<td>Fiexed size data</td>
<td>fix_alloc</td>
<td>FIXED_SIZE</td>
<td>F</td>
</tr>
<tr>
<td>Standard allocator</td>
<td>For most other data</td>
<td>std_alloc</td>
<td>STANDARD</td>
<td>D</td>
</tr>
</tbody></table>
<ul>
<li>eheap，binary, driver, ets</li>
<li>temporary<ul>
<li>c function scope</li>
<li>temp gc rootset</li>
<li>dist msg decode</li>
</ul>
</li>
<li>short lived<ul>
<li>ets match specs</li>
<li>short timers</li>
<li>fd select list</li>
</ul>
</li>
<li>standard lived<ul>
<li>links</li>
<li>monitors</li>
</ul>
</li>
<li>long lived<ul>
<li>code</li>
<li>atoms</li>
</ul>
</li>
<li>fix size<ul>
<li>process control block</li>
<li>port control block</li>
</ul>
</li>
</ul>
<h2 id="分配策略-as"><a href="#分配策略-as" class="headerlink" title="分配策略(as)"></a>分配策略(as)</h2><p>allocation strategy，从mbc中找到空闲block的策略。</p>
<ul>
<li>Block Oriented<ul>
<li>best fit: 找到满足要求的最小block，二叉平衡树，logN</li>
<li>address order best fit</li>
<li>address order first fit</li>
<li>good fit</li>
<li>a fit</li>
</ul>
</li>
<li>Carrier Oriented<ul>
<li>address order first fit carrier best fit</li>
<li>address order first fit carrier address order best fit</li>
</ul>
</li>
</ul>
<p>Carrier分配器</p>
<ul>
<li>mseg alloc<ul>
<li>/dev/zero mmap, munmap, mremap</li>
<li>cache freeed carries</li>
</ul>
</li>
<li>sys alloc<ul>
<li>maps to malloc, free</li>
<li>multiple of +Muycs to help avoid fragmentation</li>
<li>used for main carrier allocaton</li>
</ul>
</li>
</ul>
<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>erlang:system_info(allocator)</p>
<ul>
<li>sys_alloc mseg_alloc</li>
<li>eheap_alloc, ets_alloc, binary_alloc, driver_alloc</li>
<li>temp_alloc, sl_alloc, std_alloc, ll_alloc, fix_alloc</li>
</ul>
<p>erlang:system_info({allocator, Type})</p>
<h2 id="主要配置参数"><a href="#主要配置参数" class="headerlink" title="主要配置参数"></a>主要配置参数</h2><ul>
<li>sbct</li>
<li>mbc allocation strategy</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="问题一-large-binary"><a href="#问题一-large-binary" class="headerlink" title="问题一: large binary"></a>问题一: large binary</h3><ul>
<li>现象：性能低下，通过strace发现malloc比mmap多得多。</li>
<li>原因： 统计发现sbcs carrier_size 比 mbcs carrier_size大得多，大量binary放到了sbc。</li>
<li>解决方案：<ul>
<li>增大<code>+MBsbct</code>, 同时增大<code>+MBlmbcs</code>和<code>+MBsmbcs</code></li>
</ul>
</li>
</ul>
<h3 id="问题二：碎片问题"><a href="#问题二：碎片问题" class="headerlink" title="问题二：碎片问题"></a>问题二：碎片问题</h3><p>这是lyse作者在实际项目中遇到的问题，详情见作者博客<a href="https://blog.heroku.com/logplex-down-the-rabbit-hole" target="_blank" rel="noopener">logplex down the rabbit hole</a>。</p>
<ul>
<li>现象：<ul>
<li>erlang:memory(total) 7GB</li>
<li>top 显示 15GB</li>
<li>崩溃日志：ets_alloc: Cannot allocate XYZ bytes of memory. Abnormal termination</li>
</ul>
</li>
<li>原因： Carrier中残留的block导致Carrier无法回收</li>
<li>方案：减少碎片<ul>
<li><code>+MBas aobf</code> address order best fit 更集中</li>
<li>减小<code>+MBlmbcs</code> 来分配更多的小mbc，更容易被回收</li>
</ul>
</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li>Memory Management Battle Stories by lukas larsson</li>
<li><a href="http://erlang.org/doc/man/erts_alloc.html" target="_blank" rel="noopener">http://erlang.org/doc/man/erts_alloc.html</a></li>
<li><a href="https://blog.heroku.com/logplex-down-the-rabbit-hole" target="_blank" rel="noopener">logplex down the rabbit hole</a></li>
<li>The beam book</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/07/15/erlang-code-loading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/15/erlang-code-loading/" class="post-title-link" itemprop="url">Erlang代码加载模式</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-07-15 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-15T00:00:00+08:00">2017-07-15</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Erlang自带三个Boot脚本：</p>
<ul>
<li>start_clean.boot 加载和启动Kernel和STDLIB</li>
<li>start_sasl.boot 比上面多了一个SASL</li>
<li>no_dot_erlang.boot 跟第一个一样，只是不加载<code>.erlang</code><br>安装otp的时候可以选择默认脚本是start_clean还是start_sasl，选择以后会拷贝一份start.boot.</li>
</ul>
<p>ERTS中有两种代码加载模式：</p>
<ul>
<li>interactive：代码第一次被引用的时候会去代码路径中搜索并加载。</li>
<li>embedded：一开始就根据boot script来加载。</li>
</ul>
<p>code模块对外提供接口，code_server模块处理实际的工作，注册为code_server。维护一个私有ets表code。<br>预加载的10个模块，包括erlang_prim_loader，erlang，init，prim_inet，prim_file等模块，需要被code_server用到的模块都属于预加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(dev@127.0.0.1)1&gt; erlang:pre_loaded().</span><br><span class="line">[erts_internal,erlang,erl_prim_loader,prim_zip,zlib,</span><br><span class="line"> prim_file,prim_inet,prim_eval,init,otp_ring0]</span><br></pre></td></tr></table></figure>

<p>对于预定义的模块，如lists，math等等系统模块，这些模块是不能重复热更新的。这些模块所在的目录被称为<code>sticky</code>目录。<br>这是为了防止有人误操作把系统模块给替换了导致整个系统崩溃。除了这些系统模块，其他的模块都是可以热更新的。</p>
<p>ERTS系统中，一个模块可以存在两个版本。新版本(current)和老版本(old)，两个版本都是有效的。<br>代码第一次加载进来的时候是新版本，当有新的代码加载的时候，新的代码变成新版本，原来的新版本变成老版本。<br>当有第三个版本加载进来的时候，之前的老版本就需要被移除掉(purge)，<br>这样如果有进程还在执行老版本的代码，需要将这些还在执行老代码的进程杀死才能进行热更。杀死运行老代码然后purge老代码，然后加载最新代码，这是系统默认的热更方式。<br>所以一般情况下，第一次热更新模块的时候是安全的，因为系统只有一个新版本的代码。第二次热更新如果使用强制更新就可能杀死一些进程，引发一些意想不到的后果。<br>要避免这种情况，一方面是在调用代码的时候使用全名函数，一方面在热更新的时候使用软更新(soft purge)。这样如果还有进程在执行老代码，就不会执行热更新。<br>OTP框架下的模板都是支持热更新的。</p>
<h2 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h2><p>purge：是指将老版本的代码从系统中移除掉，如果仍有进程在执行老版本代码，则将这些进程杀掉。<br>soft_purge：尝试将老代码移除掉，如果仍有进程在执行老版本代码，则返回失败。</p>
<p>erlang模块提供的接口：</p>
<ul>
<li><p>erlang:check_old_code(Mod) -&gt; boolean(). 检查系统中是否存在该模块的老代码。当系统中有老代码的时候，要清除老代码（执行purge）才能加载新的代码。<br>为了清除老代码要先找到仍在执行老代码的进程，将其kill掉。</p>
</li>
<li><p>erlang:check_process_code(Pid, Mod) -&gt; boolean(). 检查进程是否在执行Mod的老代码。<br>为了找出仍在执行老代码的进程，需要遍历进程列表processes()，依次进行检查。</p>
</li>
</ul>
<p>进程仍在执行模块的老代码，有三种情况：</p>
<ul>
<li>进程正在执行老代码。这种情况下是不管进程调用的全名函数短名函数。对于全名函数，当前这次执行完了下次就会切换到新代码，所以一开始返回true，后面就false了。对于短名函数则始终为true。</li>
<li>进程包含短名函数的引用。</li>
<li>进程包含引用短名函数的fun对象。比如其他模块发送了一个fun给进程执行，这个fun对象包含了模块的短名对象，那么执行fun对象期间返回true。</li>
</ul>
<p>如果一个常驻内存的进程拿到了一个模块构造的匿名函数，那么这个模块要热更的时候就比较麻烦了。可能必须得杀死这个常驻进程才能purge模块的老代码。<br>在实际工作过程中如果对热更机制缺乏了解就会犯这样的错误。在实现战斗技能的时候，前端要求如果技能杀死对象要统一结算。所以一开始实现的时候会<br>被杀死的对象的处理函数写成匿名函数然后存到地图进程的进程字典。结果发现有时候战斗的逻辑无法热更（因为我们热更线上的代码都是采用soft_purge，不会强制杀死进程）。</p>
<p>还有一个例子就是实现玩法活动的时候，管理进程会创建一些回调函数到场景进程，这些回调函数的参数一部分由管理进程提供，一部分由地图进程提供，写成匿名函数的话非常方便。<br>但是这样的话导致活动期间活动的逻辑代码无法热更。因为要热更就必须杀死场景进程。因此这种做法应该是尽量避免的。</p>
<p>检查系统中的老代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f(OldMods),OldMods = lists:filtermap(</span><br><span class="line">    fun(&#123;Module, Filename&#125;) -&gt;</span><br><span class="line">        is_list(Filename) andalso</span><br><span class="line">        erlang:check_old_code(Module) andalso</span><br><span class="line">        &#123;true, Module&#125;</span><br><span class="line">    end,</span><br><span class="line">    code:all_loaded()</span><br><span class="line">).</span><br></pre></td></tr></table></figure>

<p>检查系统中老代码无法被purge的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lists:filtermap(</span><br><span class="line">    fun(Module) -&gt;</span><br><span class="line">        not code:soft_purge(Module)</span><br><span class="line">    end,</span><br><span class="line">    OldMods</span><br><span class="line">).</span><br></pre></td></tr></table></figure>

<p>找出还在执行老代码Mod的进程信息：<br><code>[process_info(Pid)||Pid&lt;-processes(),erlang:check_process_code(Pid, Mod)].</code></p>
<p>杀进程。一般先monitor，再kill，等待接收moniter消息，确认当前进程杀死。因为被杀死的进程可能需要进行一些清理的行为，如果不等待它确认死亡就将执行后续操作如移除代码，可能会导致清理过程出现找不到代码的问题。</p>
<p>code_server中杀死进程的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">%% do_purge(Module)</span><br><span class="line">%%  Kill all processes running code from *old* Module, and then purge the</span><br><span class="line">%%  module. Return true if any processes killed, else false.</span><br><span class="line"></span><br><span class="line">do_purge(Mod0) -&gt;</span><br><span class="line">    Mod = to_atom(Mod0),</span><br><span class="line">    case erlang:check_old_code(Mod) of</span><br><span class="line">	false -&gt; false;</span><br><span class="line">	true -&gt; do_purge(processes(), Mod, false)</span><br><span class="line">    end.</span><br><span class="line"></span><br><span class="line">do_purge([P|Ps], Mod, Purged) -&gt;</span><br><span class="line">    case erlang:check_process_code(P, Mod) of</span><br><span class="line">	true -&gt;</span><br><span class="line">	    Ref = erlang:monitor(process, P),</span><br><span class="line">	    exit(P, kill),</span><br><span class="line">	    receive</span><br><span class="line">		&#123;&apos;DOWN&apos;,Ref,process,_Pid,_&#125; -&gt; ok</span><br><span class="line">	    end,</span><br><span class="line">	    do_purge(Ps, Mod, true);</span><br><span class="line">	false -&gt;</span><br><span class="line">	    do_purge(Ps, Mod, Purged)</span><br><span class="line">    end;</span><br><span class="line">do_purge([], Mod, Purged) -&gt;</span><br><span class="line">    catch erlang:purge_module(Mod),</span><br><span class="line">    Purged.</span><br></pre></td></tr></table></figure>

<p>直接purge有杀死进程的危险性，所以code_server也提供了soft_purge，如果有进程仍在执行老代码，则不移除老代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%% do_soft_purge(Module)</span><br><span class="line">%% Purge old code only if no procs remain that run old code.</span><br><span class="line">%% Return true in that case, false if procs remain (in this</span><br><span class="line">%% case old code is not purged)</span><br><span class="line"></span><br><span class="line">do_soft_purge(Mod) -&gt;</span><br><span class="line">    case erlang:check_old_code(Mod) of</span><br><span class="line">	false -&gt; true;</span><br><span class="line">	true -&gt; do_soft_purge(processes(), Mod)</span><br><span class="line">    end.</span><br><span class="line"></span><br><span class="line">do_soft_purge([P|Ps], Mod) -&gt;</span><br><span class="line">    case erlang:check_process_code(P, Mod) of</span><br><span class="line">	true -&gt; false;</span><br><span class="line">	false -&gt; do_soft_purge(Ps, Mod)</span><br><span class="line">    end;</span><br><span class="line">do_soft_purge([], Mod) -&gt;</span><br><span class="line">    catch erlang:purge_module(Mod),</span><br><span class="line">    true.</span><br></pre></td></tr></table></figure>

<h2 id="热更机制"><a href="#热更机制" class="headerlink" title="热更机制"></a>热更机制</h2><p>在开发环境中，可以使用Mochiweb的reloader模块来进行热更。reloader的实现机制主要是每隔一秒钟检测一次系统中加载的代码对应的beam文件时间戳，<br>如果发现时间戳从上次检测以来发生了变更，就执行热更新。在开发中使用起来非常方便。我们只需要编译代码，系统自动进行加载。<br>但是reloader的热更新用的是purge，也就是说如果你的进程持有热更模块的匿名函数引用，或者不符合otp规范，比如进程的主循环用的是短名函数，那么就存在进程被杀死的风险。<br>reloader的核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">doit(From, To) -&gt;</span><br><span class="line">    [case file:read_file_info(Filename) of</span><br><span class="line">         &#123;ok, #file_info&#123;mtime = Mtime&#125;&#125; when Mtime &gt;= From, Mtime &lt; To -&gt;</span><br><span class="line">             reload(Module);</span><br><span class="line">         &#123;ok, _&#125; -&gt;</span><br><span class="line">             unmodified;</span><br><span class="line">         &#123;error, enoent&#125; -&gt;</span><br><span class="line">             %% The Erlang compiler deletes existing .beam files if</span><br><span class="line">             %% recompiling fails.  Maybe it&apos;s worth spitting out a</span><br><span class="line">             %% warning here, but I&apos;d want to limit it to just once.</span><br><span class="line">             gone;</span><br><span class="line">         &#123;error, Reason&#125; -&gt;</span><br><span class="line">             io:format(&quot;Error reading ~s&apos;s file info: ~p~n&quot;,</span><br><span class="line">                       [Filename, Reason]),</span><br><span class="line">             error</span><br><span class="line">     end || &#123;Module, Filename&#125; &lt;- code:all_loaded(), is_list(Filename)].</span><br><span class="line"></span><br><span class="line">reload(Module) -&gt;</span><br><span class="line">    io:format(&quot;Reloading ~p ...&quot;, [Module]),</span><br><span class="line">    code:purge(Module), %% **watch out**</span><br><span class="line">    case code:load_file(Module) of</span><br><span class="line">        &#123;module, Module&#125; -&gt;</span><br><span class="line">            io:format(&quot; ok.~n&quot;),</span><br><span class="line">            case erlang:function_exported(Module, test, 0) of</span><br><span class="line">                true -&gt;</span><br><span class="line">                    io:format(&quot; - Calling ~p:test() ...&quot;, [Module]),</span><br><span class="line">                    case catch Module:test() of</span><br><span class="line">                        ok -&gt;</span><br><span class="line">                            io:format(&quot; ok.~n&quot;),</span><br><span class="line">                            reload;</span><br><span class="line">                        Reason -&gt;</span><br><span class="line">                            io:format(&quot; fail: ~p.~n&quot;, [Reason]),</span><br><span class="line">                            reload_but_test_failed</span><br><span class="line">                    end;</span><br><span class="line">                false -&gt;</span><br><span class="line">                    reload</span><br><span class="line">            end;</span><br><span class="line">        &#123;error, Reason&#125; -&gt;</span><br><span class="line">            io:format(&quot; fail: ~p.~n&quot;, [Reason]),</span><br><span class="line">            error</span><br><span class="line">    end.</span><br></pre></td></tr></table></figure>

<p>实际上Erlang Shell中提供的函数的热更函数l(Module)实现就是直接purge，shell提供的函数实现在c.erl文件中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l(Mod) -&gt;</span><br><span class="line">    code:purge(Mod),</span><br><span class="line">    code:load_file(Mod).</span><br></pre></td></tr></table></figure>

<p>直接load代码存在杀死进程的危险，所以一种安全的热更机制应该先尝试soft purge，如果成功，则加载代码，失败则放弃更新。<br>检查代码是否有改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%% @doc Return a list of beam modules that have changed.</span><br><span class="line">all_changed() -&gt;</span><br><span class="line">    [M || &#123;M, Fn&#125; &lt;- code:all_loaded(), is_list(Fn), is_changed(M)].</span><br><span class="line"></span><br><span class="line">%% @spec is_changed(atom()) -&gt; boolean()</span><br><span class="line">%% @doc true if the loaded module is a beam with a vsn attribute</span><br><span class="line">%%      and does not match the on-disk beam file, returns false otherwise.</span><br><span class="line">is_changed(M) -&gt;</span><br><span class="line">    try</span><br><span class="line">        module_vsn(M:module_info()) =/= module_vsn(code:get_object_code(M))</span><br><span class="line">    catch _:_ -&gt;</span><br><span class="line">            false</span><br><span class="line">    end.</span><br><span class="line"></span><br><span class="line">%% Internal API</span><br><span class="line"></span><br><span class="line">module_vsn(&#123;M, Beam, _Fn&#125;) -&gt;</span><br><span class="line">    &#123;ok, &#123;M, Vsn&#125;&#125; = beam_lib:version(Beam),</span><br><span class="line">    Vsn;</span><br><span class="line">module_vsn(L) when is_list(L) -&gt;</span><br><span class="line">    &#123;_, Attrs&#125; = lists:keyfind(attributes, 1, L),</span><br><span class="line">    &#123;_, Vsn&#125; = lists:keyfind(vsn, 1, Attrs),</span><br><span class="line">    Vsn.</span><br></pre></td></tr></table></figure>

<p>函数<code>code:get_object_code(Module)</code>在代码路径下查找模块 <code>Module</code> 的目标代码，如果找到，则返回 <code>{Module, Binary, Filename}</code>，否则返回 <code>error</code>。</p>
<p>尝试更新代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case soft_purge(Mod) of</span><br><span class="line">true -&gt; code:load_file(Mod);</span><br><span class="line">false -&gt; error</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://erlang.org/doc/reference_manual/code_loading.html" target="_blank" rel="noopener">Compilation and Code Loading</a></li>
<li><a href="https://github.com/rustyio/sync" target="_blank" rel="noopener">sync</a></li>
<li>reloder</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/07/11/database-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/11/database-transaction/" class="post-title-link" itemprop="url">数据库事务</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-07-11 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-11T00:00:00+08:00">2017-07-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>事务需要满足ACID特征。Mysql的innodb引擎支持事务。</p>
<ul>
<li>原子性，Atomicity, 一个事务是不可分割的整体，要么全部成功(committed)，要么全部失败(rolled back)，不存在部分成功。</li>
<li>一致性，Consistency，数据总是从一致性的状态转移到另一个一致性的状态，总是处于有意义的状态。比如转账，A的钱减少，B的钱增加，总和是不变的。</li>
<li>隔离性，Isolation，主要解决多个事务<strong>并发读写</strong>的问题，一个事务未提交，那么它对数据的修改对外是不可见的。</li>
<li>持久性，Durability，一个事务一旦提交，对数据的影响的永久性的，就算断电，系统崩溃也是如此。</li>
</ul>
<p>四个性质最根本的是一致性，其他三个性质都是服务于一致性的。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>当多个进程的事务同时读写数据时，就会出现一些问题。</p>
<ul>
<li>脏读，dirty read，一个事务可以读到其他事务尚未提交的修改。尚未提交意味着可能回滚，那么该事务读到的就是无效的数据。</li>
<li>不可重复读，unrepeatable read，同一个事务范围内多次查询却返回了不同的数据，这是因为在查询间隙，数据被另外的事务修改了(update, delete)。</li>
<li>虚读，幻读，phantom read，同一个事务范围内，相同的操作两次读取的记录数不一样，比如多出来一行(add)。跟不可重复读的对象不一样，幻读针对的是一批数据，而后者指的是同一个数据。</li>
</ul>
<p>innodb通过不同的锁策略支持四个级别的隔离性。</p>
<ul>
<li>Read uncommitted，最低级别，任何情况都无法保证。</li>
<li>Read committed，可避免脏读。</li>
<li>Repeatable read，在Sql标准中，RR级别可避免脏读和不可重复读，但是还存在幻读。RR是innodb的默认级别，innodb的RR解决了幻读的问题。</li>
<li>Serializable，最高级别，可避免脏读，不可重复读，幻读的发生，效率最低，一般通过锁表来实现。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>已提交读(RC)</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>可重复读(RR)</td>
<td>No</td>
<td>No</td>
<td>Yes(注：Innodb的RR级别通过gap锁解决了幻读)</td>
</tr>
<tr>
<td>可串行化</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
</tbody></table>
<p>mysql中查看隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@global.tx_isolation, @@tx_isolation;</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| @@global.tx_isolation | @@tx_isolation |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| READ-COMMITTED        | READ-COMMITTED |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>innodb可以通过下面的命令设置隔离级别，注意带global, session或者都不带效果是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set [global | session] transaction isolation level [read uncommitted |read committed |repeatable read | serializable];</span><br></pre></td></tr></table></figure>

<ul>
<li>With the GLOBAL keyword, the statement applies globally for all subsequent sessions. Existing sessions are unaffected.</li>
<li>With the SESSION keyword, the statement applies to all subsequent transactions performed within the current session.</li>
<li>Without any SESSION or GLOBAL keyword, the statement applies to the next (not started) transaction performed within the current session. Subsequent transactions revert to using the SESSION isolation level.</li>
</ul>
<p>在事务内部无法修改下一个事务的隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set transaction isolation level serializable;</span><br><span class="line">ERROR 1568 (25001): Transaction isolation level can&apos;t be changed while a transaction is in progress</span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; set transaction isolation level serializable;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set tx_isolation = &apos;read-uncommitted&apos;;</span><br><span class="line">set tx_isolation = &apos;read-committed&apos;;</span><br><span class="line">set tx_isolation = &apos;repeatable-read&apos;;</span><br><span class="line">set tx_isolation = &apos;serializable&apos;;</span><br></pre></td></tr></table></figure>

<h2 id="2PL-Two-Phase-Locking"><a href="#2PL-Two-Phase-Locking" class="headerlink" title="2PL: Two-Phase Locking"></a>2PL: Two-Phase Locking</h2><p>传统RDBMS加锁的一个原则，二阶段锁。锁操作分为两个阶段：加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。</p>
<ul>
<li>加锁阶段：只加锁，不放锁。</li>
<li>解锁阶段：只放锁，不加锁。</li>
</ul>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>如果一个条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由MySQL Server层进行过滤。<br>但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。<br>这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见即使是MySQL，为了效率也是会违反规范的。</p>
<p>这种情况同样适用于MySQL的默认隔离级别RR。所以对一个数据量很大的表做批量修改的时候，如果无法使用相应的索引，<br>MySQL Server过滤数据的的时候特别慢，就会出现虽然没有修改某些行的数据，但是它们还是被锁住了的现象。</p>
<h2 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h2><p>与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control，最大的好处是，读不加锁，读写不冲突。<br>InnoDB中，每行数据后添加两个额外的隐藏的值来实现MVCC。一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。<br>在实际操作中，存储的并不是时间，而是事务的版本号。每开启一个新事务，事务的版本号就会递增。<br>在RR事务隔离级别下：</p>
<ul>
<li>select时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或者大于当前事务版本号的记录。</li>
<li>insert时，保存当前事务版本号为行的创建版本号。</li>
<li>delete时，保存当前事务版本号位行的删除版本号。</li>
<li>update时，插入一条新记录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号为原来行的删除版本号。</li>
</ul>
<p>通过MVCC，每行记录都需要额外的存储空间，更多的行检查工作和额外的维护工作，但是可以减少锁的使用。大多数操作都不用加锁。<br>读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p>
<p>Mysql的RR级别是解决了幻读的问题的。</p>
<h3 id="快照读-snapshot-read"><a href="#快照读-snapshot-read" class="headerlink" title="快照读 snapshot read"></a>快照读 snapshot read</h3><p>简单的select操作，属于快照读，读取记录的可见版本，不用加锁。</p>
<ul>
<li>select * from table where ?;</li>
</ul>
<h3 id="当前读-current-read"><a href="#当前读-current-read" class="headerlink" title="当前读 current read"></a>当前读 current read</h3><p>特殊的读操作，以及插入，更新，删除操作，属于当前读。</p>
<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert into table values (…);</li>
<li>update table set ? where ?;</li>
<li>delete from table where ?;</li>
</ul>
<p>读取的是记录的最新版本，并且当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。<br>除了第一条语句对读取记录加S锁（共享锁）外，其他的操作都加的是X锁（排它锁）。</p>
<h3 id="GAP间隙锁"><a href="#GAP间隙锁" class="headerlink" title="GAP间隙锁"></a>GAP间隙锁</h3><p>幻读无法通过行锁来解决。<br>行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</p>
<p>有索引的时候，Gap锁很多时候会锁住不需要锁的区间。<br>没有索引的时候，Gap锁会锁住所有记录，但是innodb不会主动升级表锁。</p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>不区分快照读与当前读，所有读操作均为当前读。<br>读加共享锁(S锁)，写加排它锁(X锁)，读写互斥。使用悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发特别少或者没有并发，<br>同时有要求数据及时可靠的话，可以使用这种模式。这个级别下select也是会加锁的。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁的本质是两个以上的session对资源的加锁顺序不一致。解决死锁的关键在于让不同的session加锁有次序。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></li>
<li><a href="http://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="noopener">数据库事务的四大特性以及事务的隔离级别</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/set-transaction.html" target="_blank" rel="noopener">SET TRANSACTION Syntax</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" target="_blank" rel="noopener">Transaction Isolation Levels</a></li>
<li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/07/05/beam-virtual-machine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/07/05/beam-virtual-machine/" class="post-title-link" itemprop="url">Beam虚拟机</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-07-05 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-05T00:00:00+08:00">2017-07-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过-S选项可以将erl源文件编译成汇编文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ erlc -S test.erl</span><br></pre></td></tr></table></figure>

<p>反编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beam_lib:chunks(&quot;hw.beam&quot;, [abstract_code]).</span><br></pre></td></tr></table></figure>

<h2 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h2><ul>
<li>Code area，代码区，存放加载的编译的Erlang代码。</li>
<li>stack，调用栈，保存call frames调用帧，包括局部变量以及返回地址。</li>
<li>heap，堆，执行过程中创建的term。<br>堆和栈位于同一块内存区域的两端，向彼此的方向增长，栈从高地址向低地址增长，堆从低地址向高地址增长，这种实现使得判别内存是否溢出非常简单，只要比较一下寄存器中的两个指针的大小即可。<br>每个调用帧以一个返回地址CP开始，接着是局部变量。局部变量通过距离栈顶的偏移值来访问。调用帧的分配和回收通过A_op和D_op指令完成，指令后面跟调用帧的大小N。<br>调用帧也能包含catch的恢复地址和下一条指令的地址。</li>
</ul>
<p>Erlang虚拟机允许调用c编译的函数，当调用编译成c的函数，下条指令地址I保存在调用帧。CP指针指向的是函数返回时恢复I指针的代码地址。</p>
<h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>一个Erlang term以一个32位的无符号数表示，分为value和tag。tag为最低位4bit，用于区分term的类型。</p>
<ul>
<li>对于atom，value字段是全局atom表的索引地址。</li>
<li>对于小整数，value字段就是整数本身。</li>
<li>对于大整数，value是指向堆对象的一个指针，堆对象包含了整数的符号以及数字。</li>
<li>对于list，value是一个指针，指向两个连续的堆对象，一个头，一个尾。</li>
<li>对于tuple，指向的是堆对象，包含tuple的大小以及tuple的元素。</li>
<li>对于浮点数，指向的是一个两个字的浮点数。</li>
<li>对于pid，value就是pid本身。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define SMALL          15              /* small integer       */</span><br><span class="line">#define BIG            11              /* big integer pointer */</span><br><span class="line">#define FLOAT           9              /* float pointer       */</span><br><span class="line">#define ATOM            7              /* atom                */</span><br><span class="line">#define REFER           6              /* reference           */</span><br><span class="line">#define PORT            5              /* port                */</span><br><span class="line">#define PID             3              /* process identifier  */</span><br><span class="line">#define TUPLE           2              /* tuple pointer       */</span><br><span class="line">#define NIL            (BIG + 16)      /* empty list          */</span><br><span class="line">#define LIST            1              /* list pointer        */</span><br><span class="line">#define ARITYVAL       10              /* tuple arity         */</span><br><span class="line">#define MOVED          12              /* moved heap pointer  */</span><br><span class="line">#define CATCH          THING           /* resumption address  */</span><br><span class="line">#define THING          13              /* float value         */</span><br><span class="line">#define BINARY         14              /* binary pointer      */</span><br><span class="line">#define BLANK          ARITYVAL        /* blank local var     */</span><br><span class="line">#define IC             SMALL           /* next instr. pointer */</span><br><span class="line"></span><br><span class="line">#define CP0             0              /* CP pointer          */</span><br><span class="line">#define CP4             4              /* CP pointer          */</span><br><span class="line">#define CP8             8              /* CP pointer          */</span><br><span class="line">#define CP12           12              /* CP pointer          */</span><br></pre></td></tr></table></figure>

<p>由于有些数据只可能存在堆或栈中，所以同样的tag可以被两个不同的对象使用。如CATCH和THING，BLANK和ARITYVAL。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><ul>
<li>HTOP，堆顶指针</li>
<li>E，栈顶指针</li>
<li>CP，Continuation Pointer, 返回地址指针（函数返回后去哪里）</li>
<li>PC，Program Counter，下一条执行指令地址</li>
<li>I，下一个指令地址</li>
<li>x(N)，1024个x寄存器，参数寄存器（用来传递函数参数），x(N)也用来保存临时变量</li>
<li>y(N)，局部变量，（y(N)并不是真的寄存器，他们存在于调用帧中，通过栈顶指针的偏移值来访问）</li>
<li>fcalls，reduction计数，用于进程调度</li>
</ul>
<h2 id="重要的指令"><a href="#重要的指令" class="headerlink" title="重要的指令"></a>重要的指令</h2><p>函数调用时， 把参数加载到参数寄存器x(N), 更新返回地址寄存器CP，函数返回时，返回值保存在x(0)</p>
<ul>
<li>test</li>
<li>move <code>{move, Src, Dest}</code></li>
<li>gc_bif</li>
<li>call <code>{call, Arity, {f, N}}</code><ul>
<li>set <code>P=N, CP=Next</code></li>
<li>jumps to label <code>N</code></li>
<li>arguments are stored in X0 ~ Xn</li>
</ul>
</li>
<li>return<ul>
<li>does <code>PC=CP</code></li>
<li>return value is stored in X0</li>
</ul>
</li>
<li>receive</li>
<li>allocate</li>
<li>deallocate <code>{deallocate, N}</code><ul>
<li>create and remove stack frames.</li>
<li>there also exists <code>{allocate_zero, Ny, Ng}</code> - <code>Ny</code> Y registers</li>
</ul>
</li>
<li>label <code>{label, N}</code><ul>
<li>Nth label in the module</li>
</ul>
</li>
<li>function <code>{function, Name, Arity, LabelID}</code><ul>
<li>defines a function</li>
</ul>
</li>
<li>bif <code>{bif, FuncAtom, {f, 0}, [], {x, 0}}</code></li>
<li>gc_bif <code>{gc_bif, &#39;*&#39;, {f, A}, N1, [R1, R2, R3]}</code><ul>
<li>jumps to a function named <code>&#39;*&#39;</code></li>
<li>multiply R1 and R2, and set the result into R3. If any failure occurs jump to <code>A</code>. If GC is triggered include N1 X registers starting at X0 in the root set for GC.</li>
</ul>
</li>
<li>send <code>send.</code><ul>
<li>sends the data in <code>X0</code> ?</li>
</ul>
</li>
<li>loop_rec <code>{loop_rec, {f, N}, {x, 0}}</code><ul>
<li>receive clause starts here, till <code>loop_rec_end</code></li>
</ul>
</li>
<li>wait_timeout <code>{wait_timeout, {f, N}, {integer, T}}</code></li>
<li>test <code>{test, is_eq_exact, {f, N}, [{x,0}, {atom, foo}]}</code></li>
<li><code>remove_message.</code></li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>每个进程有自己的堆栈空间，进程执行固定数量的reduction以后挂起加入调度队列，然后调度器从队列中取出第一个进程执行。<br>每个进程有自己的消息队列，发消息意味着拷贝消息到目标进程的堆中，并将消息地址加入目标进程的消息队列中。<br>进程在等待消息的时候被交换出去，直到有新消息到来或者超时的时候重新加入调度队列。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://www.cs-lab.org/historical_beam_instruction_set.html" target="_blank" rel="noopener">The Erlang BEAM Virtual Machine Specification</a></li>
<li><a href="https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/" target="_blank" rel="noopener">How to “Build” a Computer</a></li>
<li><a href="https://github.com/erlang/otp/blob/master/lib/compiler/src/genop.tab" target="_blank" rel="noopener">instruction set</a></li>
<li><a href="https://github.com/erlang/otp/blob/master/erts/emulator/beam/beam_emu.c#L1103" target="_blank" rel="noopener">beam_emu.c</a></li>
<li><a href="https://github.com/mfoemmel/erlang-otp/blob/master/lib/compiler/src/beam_opcodes.erl" target="_blank" rel="noopener">beam_opcodes.erl</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/06/21/selective-receive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/06/21/selective-receive/" class="post-title-link" itemprop="url">Erlang的Selective Receive机制</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-06-21 00:00:00" itemprop="dateCreated datePublished" datetime="2017-06-21T00:00:00+08:00">2017-06-21</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Selective-Receive"><a href="#Selective-Receive" class="headerlink" title="Selective Receive"></a>Selective Receive</h2><p>Joe的Programming Erlang中讲到了Selective Receive的时候，提到了一个<code>save queue</code>的概念。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; receive</span><br><span class="line">&gt;   Pattern1 [when Guard1] -&gt;</span><br><span class="line">&gt;   Expressions1;</span><br><span class="line">&gt;   Pattern2 [when Guard2] -&gt;</span><br><span class="line">&gt;   Expressions2;</span><br><span class="line">&gt;   ...</span><br><span class="line">&gt; after</span><br><span class="line">&gt;   Time -&gt;</span><br><span class="line">&gt;   ExpressionsTimeout</span><br><span class="line">&gt; end</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>When we enter a receive statement, we start a timer (but only if an after section is present in the expression).</li>
<li>Take the first message in the mailbox and try to match it against Pattern1, Pattern2, and so on. If the match succeeds, the message is removed from the mailbox, and the expressions following the pattern are evaluated.</li>
<li>If none of the patterns in the receive statement matches the first message in the mailbox, then the first message is removed from the mailbox and put into a “<em>save queue</em>.” The second message in the mailbox is then tried. This procedure is repeated until a matching message is found or until all the messages in the mailbox have been examined.</li>
<li>If none of the messages in the mailbox matches, then the process is suspended and will be rescheduled for execution the next time a new message is put in the mailbox. Note that when a new message arrives, the messages in the save queue are not rematched; only the new message is matched.</li>
<li>As soon as a message has been matched, then all messages that have been put into the save queue are reentered into the mailbox in the order in which they arrived at the process. If a timer was set, it is cleared.</li>
<li>If the timer elapses when we are waiting for a message, then evaluate the expressions ExpressionsTimeout and put any saved messages back into the mailbox in the order in which they arrived at the process.</li>
</ul>
</blockquote>
<p>在进入一个receive语句的时候，没有被匹配的消息被临时移到<code>save queue</code>中，等当前receive语句匹配到消息以后再移回消息队列。那么为什么不能直接丢弃这些没有被匹配的消息呢？<br>要回答这个问题，就不能把思维局限在一个receive语句。实际上，在进程中，receive语句可以是嵌套，可以是串联的，当前不能匹配的消息，是可能在嵌套的receive或者后续的receive匹配到的。<br>丢弃消息会出现问题。当然为了防止未知消息的堆积，一般会有一个匹配一切的语句，remove掉不需要的消息。</p>
<p><img src="selective_receive.png" alt="selective receive"></p>
<p>嵌套的receive：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">loop</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;smoke, Smoker, AvailableMaterials&#125; -&gt;</span><br><span class="line">            Smoker ! smoke,</span><br><span class="line">            <span class="keyword">receive</span></span><br><span class="line">                doneSmoke -&gt;</span><br><span class="line">                    loop()</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>以及：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">loop</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;high_prio, Msg&#125; -&gt;</span><br><span class="line">            process_high;</span><br><span class="line">        <span class="keyword">after</span> <span class="number">0</span> -&gt;</span><br><span class="line">            <span class="keyword">receive</span></span><br><span class="line">                &#123;low_prio, Msg&#125; -&gt;</span><br><span class="line">                    process_low;</span><br><span class="line">                _ -&gt;</span><br><span class="line">                    ok</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    loop()</span><br></pre></td></tr></table></figure>

<p>串联的receive：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">receive</span></span><br><span class="line">    foo -&gt; ok</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="keyword">receive</span></span><br><span class="line">    bar -&gt; ok</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>启动一个分布式节点，方便通过远程shell连过来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(foo@deng)1&gt; erlang:register(shell,self()).</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>向shell进程发消息，并进入匹配。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(foo@deng)<span class="number">2</span>&gt; self() ! c, self() ! d, self() ! a.</span><br><span class="line">a</span><br><span class="line">(foo@deng)<span class="number">3</span>&gt; process_info(self(),messages).</span><br><span class="line">&#123;messages,[c,d,a]&#125;</span><br><span class="line">(foo@deng)<span class="number">4</span>&gt; <span class="keyword">receive</span> a -&gt; ok <span class="keyword">end</span>.</span><br><span class="line">ok</span><br><span class="line">(foo@deng)<span class="number">5</span>&gt; process_info(self(),messages).</span><br><span class="line">&#123;messages,[c,d]&#125;</span><br><span class="line">(foo@deng)<span class="number">6</span>&gt; <span class="keyword">receive</span> a -&gt; ok <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>这时候shell进入了receive的等待过程，按照之前的说法，这时候shell的消息队列应该为空，我们通过远程shell连上来查看shell的消息队列。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(foo@deng)<span class="number">3</span>&gt; process_info(whereis(shell),messages).</span><br><span class="line">&#123;messages,[c,d]&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到shell的进程队列并不为空。</p>
<h2 id="求证"><a href="#求证" class="headerlink" title="求证"></a>求证</h2><p>在官网上找到一段对receive的描述：</p>
<blockquote>
<p>Each process has its own input queue for messages it receives. New messages received are put at the end of the queue. When a process executes a receive, the first message in the queue is matched against the first pattern in the receive. If this matches, the message is removed from the queue and the actions corresponding to the pattern are executed.</p>
<p>However, if the first pattern does not match, the second pattern is tested. If this matches, the message is removed from the queue and the actions corresponding to the second pattern are executed. If the second pattern does not match, the third is tried and so on until there are no more patterns to test. If there are no more patterns to test, the first message is <strong>kept in the queue</strong> and the second message is tried instead. If this matches any pattern, the appropriate actions are executed and the second message is removed from the queue (keeping the first message and any other messages in the queue). If the second message does not match, the third message is tried, and so on, until the end of the queue is reached. If the end of the queue is reached, the process blocks (stops execution) and waits until a new message is received and this procedure is repeated.</p>
<p>The Erlang implementation is “clever” and minimizes the number of times each message is tested against the patterns in each receive.</p>
</blockquote>
<p>并没有提到save queue，消息没有被匹配的时候是留在消息队列中的。</p>
<h2 id="深入源码"><a href="#深入源码" class="headerlink" title="深入源码"></a>深入源码</h2><p>beam_receive.erl文件中有这么一段：</p>
<blockquote>
<p>In code such as:</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;    Ref = make_ref(),        %Or erlang:monitor(process, Pid)</span><br><span class="line">&gt;      .</span><br><span class="line">&gt;      .</span><br><span class="line">&gt;      .</span><br><span class="line">&gt;    receive</span><br><span class="line">&gt;       &#123;Ref,Reply&#125; -&gt; Reply</span><br><span class="line">&gt;    end.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>we know that none of the messages that exist in the message queue<br>before the call to make_ref/0 can be matched out in the receive<br>statement. Therefore we can avoid going through the entire message<br>queue if we introduce two new instructions (here written as<br>BIFs in pseudo-Erlang):<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;    recv_mark(SomeUniqInteger),</span><br><span class="line">&gt;    Ref = make_ref(),</span><br><span class="line">&gt;      .</span><br><span class="line">&gt;      .</span><br><span class="line">&gt;      .</span><br><span class="line">&gt;    recv_set(SomeUniqInteger),</span><br><span class="line">&gt;    receive</span><br><span class="line">&gt;       &#123;Ref,Reply&#125; -&gt; Reply</span><br><span class="line">&gt;    end.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>The recv_mark/1 instruction will save the current position and<br>SomeUniqInteger in the process context. The recv_set<br>instruction will verify that SomeUniqInteger is still stored<br>in the process context. If it is, it will set the current pointer<br>for the message queue (the next message to be read out) to the<br>position that was saved by recv_mark/1.</p>
<p>The remove_message instruction must be modified to invalidate<br>the information stored by the previous recv_mark/1, in case there<br>is another receive executed between the calls to recv_mark/1 and<br>recv_set/1.</p>
<p>We use a reference to a label (i.e. a position in the loaded code)<br>as the SomeUniqInteger.</p>
</blockquote>
<p>beam_emu.c文件中画出了receive语句的执行流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Skeleton for receive statement:</span><br><span class="line"></span><br><span class="line">            recv_mark L1                     Optional</span><br><span class="line">            call make_ref/monitor            Optional</span><br><span class="line">            ...</span><br><span class="line">            recv_set L1                      Optional</span><br><span class="line">     L1:          &lt;-------------------+</span><br><span class="line">                  &lt;-----------+       |</span><br><span class="line">    	     	       	  |   	  |</span><br><span class="line">            loop_rec L2 ------+---+   |</span><br><span class="line">            ...               |   |   |</span><br><span class="line">            remove_message 	  |   |	  |</span><br><span class="line">            jump L3           |   |   |</span><br><span class="line">	...	          |   |   |</span><br><span class="line">	loop_rec_end L1 --+   |   |</span><br><span class="line">     L2:          &lt;---------------+   |</span><br><span class="line">   	wait L1  -----------------+      or wait_timeout</span><br><span class="line">	timeout</span><br><span class="line"></span><br><span class="line"> L3:    Code after receive...</span><br></pre></td></tr></table></figure>

<p>erl_process.h定义了process结构，包含两个队列，一个公共队列，对于支持SMP的进程，可能存在多个进程同时向一个进程写消息的情况，这种情况下需要给消息队列加锁，这意味着进程自己处理消息的时候也需要加锁。<br>为了提高效率，引入了一个ErlMessageInQueue，其他进程先把消息写入这个进程，进程自己通过ErlMessageQueue来读取消息。这里我们重点关注ErlMessageQueue.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ERTS_SMP</span></span><br><span class="line">    ErlMessageInQueue msg_inq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ErlMessageQueue msg; <span class="comment">// message queue</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ErlMessageQueue的结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    ErlMessage* first;</span><br><span class="line">    ErlMessage** last;  /* point to the last next pointer */</span><br><span class="line">    ErlMessage** save;</span><br><span class="line">    Sint len;            /* queue length */</span><br><span class="line">    /*</span><br><span class="line">     * The following two fields are used by the recv_mark/1 and</span><br><span class="line">     * recv_set/1 instructions.</span><br><span class="line">     */</span><br><span class="line">    BeamInstr* mark;		/* address to rec_loop/2 instruction */</span><br><span class="line">    ErlMessage** saved_last;	/* saved last pointer */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取当前消息，读取的是save指针指向的消息，最开始进入匹配的时候，save是指向链表头的，消息匹配不成功以后save向后移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Get &quot;current&quot; message */</span><br><span class="line">#define PEEK_MESSAGE(p)  (*(p)-&gt;msg.save)</span><br></pre></td></tr></table></figure>

<p>下面我们通过汇编文件来分析receive的过程，先编辑一个源文件：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(test)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-compile</span><span class="params">(export_all)</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">t</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        ok -&gt; ok</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&gt; c(test).</span><br><span class="line">&#123;ok,test&#125;</span><br><span class="line">2&gt; erts_debug:df(test).</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<p>在目录下找到<code>test.dis</code>文件，找到函数t的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">08235938: i_func_info_IaaI 0 test t 0</span><br><span class="line">0823594C: i_loop_rec_fr f(08235974) x(0)</span><br><span class="line">08235954: i_is_eq_exact_immed_frc f(0823596C) x(0) ok</span><br><span class="line">08235960: remove_message</span><br><span class="line">08235964: move_return_cr ok x(0)</span><br><span class="line">0823596C: loop_rec_end_f test:t/0</span><br><span class="line">08235974: wait_locked_f test:t/0</span><br></pre></td></tr></table></figure>

<p>实现在<code>beam_emu.c</code>中:</p>
<ul>
<li>i_loop_rec_fr: Pick up the next message and place it in x(0),  If no message, jump to a wait or wait_timeout instruction.</li>
<li>loop_rec_end_f: Advance the save pointer to the next message (the current message didn’t match), then jump to the loop_rec instruction.</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>实际上并不存在<code>save queue</code>这一实体，也不存在消息在<code>save queue</code>和<code>message queue</code>之间相互拷贝，save queue可能只是老爷子为了说阐述消息匹配机制引入的一个抽象。<br>消息没有匹配到的时候只是将save指针向后移一个单位。</p>
<ul>
<li>对于每一次receive，每个消息最多匹配一次。没有匹配的消息在有新消息进来的时候并不会重新匹配，而是直接匹配新消息。</li>
<li>一旦有消息匹配完成或者超时，save指针重置，意味着下次进入receive仍然要消息队列的最开始进行匹配。无法匹配的消息这时候会再次进行匹配。可以通过make_ref来避免。</li>
<li>要防止进程中存在无法匹配的消息。因为消息堆积起来对性能产生负面影响，每次receive都会对这些消息进行匹配。</li>
</ul>
<p>PS：本文所有实现基于R1603版本。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://erlang.org/doc/getting_started/conc_prog.html" target="_blank" rel="noopener">Concurrent Programming</a></li>
<li><a href="http://ndpar.blogspot.hk/2010/11/erlang-explained-selective-receive.html" target="_blank" rel="noopener">Erlang explained: Selective receive</a></li>
<li><a href="http://learnyousomeerlang.com/more-on-multiprocessing" target="_blank" rel="noopener">More On Multiprocessing</a></li>
<li><a href="http://blog.csdn.net/mycwq/article/details/44049749" target="_blank" rel="noopener">探讨erlang消息选择性接收特性</a></li>
<li><a href="http://www.cnblogs.com/me-sa/archive/2013/03/06/make_ref.html" target="_blank" rel="noopener">make_ref 与 Selective Receive</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://wudeng.github.io/2017/06/08/behavior-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deng 的梦呓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2017/06/08/behavior-tree/" class="post-title-link" itemprop="url">基于Erlang的行为树实现</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2017-06-08 00:00:00" itemprop="dateCreated datePublished" datetime="2017-06-08T00:00:00+08:00">2017-06-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-24 22:16:26" itemprop="dateModified" datetime="2019-08-24T22:16:26+08:00">2019-08-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>行为树，英文是Behavior Tree，简称BT，是由行为节点组成的树状结构。行为树的每个节点都会返回一个状态，成功，失败，运行，父节点根据子节点的返回值做出相应的决策。在游戏开发中，行为树主要用来实现怪物AI的行为决策，根据条件以及环境来决定怪物执行什么样的行为，如攻击，逃跑，巡逻，休息等。</p>
<h2 id="为什么使用行为树"><a href="#为什么使用行为树" class="headerlink" title="为什么使用行为树"></a>为什么使用行为树</h2><p>怪物行为的控制一般来说有三种方法，</p>
<ul>
<li>最简单的if-else嵌套。这种方法最直观，但是维护起来比较困难。</li>
<li>第二种方法是有限状态机。根据怪物当前所处的状态和当前的环境，决定状态如何迁移。当状态较多时，状态之间的迁移会比较复杂。而且增加状态时需要改动的地方很多。</li>
<li>行为树相对于前两种方式的优势在于，他实现了控制逻辑与行为逻辑的分离，控制逻辑就是行为树，行为逻辑则是各个行为节点。<br>对于游戏开发来说，我们可以让策划通过行为树编辑器来编辑行为树，程序只需要实现具体的行为节点，就可以实现行为决策。</li>
</ul>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>行为树的结构如图。</p>
<p><img src="bt_architecture.png" alt="bt architecture"></p>
<p>行为树有四种类型的节点，分别是</p>
<ul>
<li>控制节点，最主要的是选择节点（Selector）和顺序节点（Sequence）。控制节点都不是叶子节点，它根据子节点的返回值返回成功，失败，运行这三种状态。</li>
<li>行为节点，具体的行为逻辑，如逃跑，巡逻。行为节点一般是叶子节点，返回成功，失败，运行这三种状态。</li>
<li>条件节点，叶子节点，返回成功，失败这两种状态。</li>
<li>装饰节点，非叶子节点，实现一些附加的逻辑。如取反。</li>
</ul>
<p>每个执行AI的实体拥有一个Tick实例，这个实例保存了这个执行实体的状态参数，以及一个可读写的黑板。<br>黑板（blackboard）是行为树实现中用来存储变量，感知环境的一个概念，节点可以访问黑板来存取变量。<br>执行实体的数据可以直接写入黑板，而行为树节点的执行数据需要加上节点id写入黑板。</p>
<p>行为树一般以一定的频率周期性的执行tick函数，每次tick都从根节点开始执行。有一些行为树会直接从返回运行的节点开始执行，这样的话如果有低优先级的节点一直返回运行状态，<br>遇到高优先级的节点时则无法打断低优先级的节点。比如怪物在巡逻的时候返回运行，这时候如果有玩家攻击它，合理的反应是进行反击或者逃跑，但是如果每次tick都从巡逻节点开始执行，<br>则根本不会处理到反击或逃跑的逻辑。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>Erlang版行为树的具体实现参考了Behavior3的版本。每个节点的有5个回调函数。</p>
<ul>
<li>enter_cb 每次tick都会执行</li>
<li>open_cb  只有未打开的节点会执行，如果节点有running状态，意味着节点处于running状态会跨越多个tick，然而只有打开节点的那个tick会执行该函数。<br>  主要用来执行节点的初始化。比如移动节点设置目标点。等待节点用来设置开始时间等。</li>
<li>tick_cb  节点的主逻辑。每个tick都会执行。</li>
<li>close_cb 跟open_cb对应，只有结束节点的时候执行。意味着跨越多个tick的runing节点这个函数只会执行一次。一般用来关闭节点。</li>
<li>exit_cb 每个tick都会执行。</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execute</span><span class="params">(#node&#123;id = Id&#125; = Node, #tick&#123;blackboard = Blackboard&#125; = Tick)</span> -&gt;</span></span><br><span class="line">    Tick1 = enter_cb(Node, Tick),</span><br><span class="line">    Tick2 = <span class="keyword">case</span> get_key(&#123;is_open, Id&#125;, Blackboard, false) <span class="keyword">of</span></span><br><span class="line">        <span class="literal">false</span> -&gt; open_cb(Node, Tick1);</span><br><span class="line">        <span class="literal">true</span> -&gt; Tick1</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    &#123;Status, Tick3&#125; = tick_cb(Node, Tick2),</span><br><span class="line">    Tick4 = <span class="keyword">case</span> Status <span class="keyword">of</span></span><br><span class="line">        running -&gt; Tick3;</span><br><span class="line">        _ -&gt; close_cb(Node, Tick3)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    Tick5 = exit_cb(Node, Tick4),</span><br><span class="line">    &#123;Status, Tick5&#125;.</span><br></pre></td></tr></table></figure>

<p>选择节点priority，顺序执行子节点，如果子节点返回成功则返回成功，跳过后续子节点。<br>如果失败则继续执行后面的子节点，直到有节点返回成功或者运行为止。如果所有节点都失败，则返回失败。<br>如果子节点返回运行则该节点也返回运行。</p>
<p>如果需要记住上次运行的节点，下次直接从该运行子节点开始执行，可以使用mem_priority类型的节点。<br>如果子节点包含两个以上可能返回运行的子节点，则需要考虑是否使用mem_priority版本。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">priority</span><span class="params">([], Tick)</span> -&gt;</span></span><br><span class="line">    &#123;false, Tick&#125;;</span><br><span class="line"><span class="function"><span class="title">priority</span><span class="params">([C|Children], Tick)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">case</span> execute(C, Tick) <span class="keyword">of</span></span><br><span class="line">        &#123;true, NewTick&#125; -&gt;</span><br><span class="line">            &#123;true, NewTick&#125;;</span><br><span class="line">        &#123;running, NewTick&#125; -&gt;</span><br><span class="line">            &#123;running, NewTick&#125;;</span><br><span class="line">        &#123;false, NewTick&#125; -&gt;</span><br><span class="line">            priority(Children, NewTick)</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>顺序节点，顺序执行子节点，如果子节点返回失败则返回失败，跳过后续子节点。<br>如果子节点返回成功，则继续执行后续子节点，直到有节点返回失败或者运行为止。如果所有子节点都成功，则返回成功，<br>如果子节点返回运行，则该节点也返回运行。</p>
<p>类似mem_priority, 顺序节点也有一个mem_sequence节点，如果有两个以上子节点可能返回运行状态，则需要考虑是否使用mem_sequence.<br>比如，怪物执行巡逻，顺序节点有两个子节点，分别执行移动到A点，和移动到B点，那么必须使用mem_sequence，<br>每次tick从上次运行的地方继续运行。否则怪物只会在A点附近反复移动，无法移动到B点。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sequence</span><span class="params">([], Tick)</span> -&gt;</span></span><br><span class="line">    &#123;true, Tick&#125;;</span><br><span class="line"><span class="function"><span class="title">sequence</span><span class="params">([C|Children], Tick)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">case</span> execute(C, Tick) <span class="keyword">of</span></span><br><span class="line">        &#123;running, NewTick&#125; -&gt;</span><br><span class="line">            &#123;running, NewTick&#125;;</span><br><span class="line">        &#123;false, NewTick&#125; -&gt;</span><br><span class="line">            &#123;false, NewTick&#125;;</span><br><span class="line">        &#123;true, NewTick&#125; -&gt;</span><br><span class="line">            sequence(Children, NewTick)</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>要注意的一个问题是，当出现高优先级的行为B1打断低优先级行为B2时，因为每次从根节点开始tick，B2的无法从内部正常的关闭。这时候需要在主逻辑上额外处理一下上上次打开的节点，<br>即调用一下这些节点的close函数。Behavior3的实现中通过比较本次的开放节点列表和上次的开放节点列表，找出上次开放，本次没有开放的节点来关闭，这样可能存在一个问题。<br>也就是当上次开放的节点在本次tick正常结束的情况下，仍然会被重新关闭一次，即一个节点关闭了两次。 Behavior3的实现就存在这样的bug。<br>解决的办法是，在判断节点是否需要关闭的时候，检测一下节点是否开放，如果是开放，则关闭，否则不予处理。<br>Erlang版本的实现中通过遍历行为树节点来找到未正常关闭的节点，考虑到行为树通常不会很大，性能上也可以接受。</p>
<p>遍历行为树关闭未能正常关闭的节点的实现：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">close_nodes</span><span class="params">(_, _, [], Tick)</span> -&gt;</span> Tick;</span><br><span class="line"><span class="function"><span class="title">close_nodes</span><span class="params">(undefined, _, _, Tick)</span> -&gt;</span> Tick;</span><br><span class="line"><span class="function"><span class="title">close_nodes</span><span class="params">(#node&#123;children = [], child = undefined&#125; = Node, CurOpenNodes, LastOpenNodes, Tick)</span> -&gt;</span></span><br><span class="line">    close_node(Node, CurOpenNodes, LastOpenNodes, Tick);</span><br><span class="line"><span class="function"><span class="title">close_nodes</span><span class="params">(#node&#123;children = Children, child = undefined&#125; = Node, CurOpenNodes, LastOpenNodes, Tick)</span> -&gt;</span></span><br><span class="line">    NewTick = close_node(Node, CurOpenNodes, LastOpenNodes, Tick),</span><br><span class="line">    lists:foldl(</span><br><span class="line">        <span class="keyword">fun</span>(Child, Acc) -&gt;</span><br><span class="line">            close_nodes(Child, CurOpenNodes, LastOpenNodes, Acc)</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">        NewTick,</span><br><span class="line">        Children</span><br><span class="line">    );</span><br><span class="line"><span class="function"><span class="title">close_nodes</span><span class="params">(#node&#123;children = [], child = Child&#125; = Node, CurOpenNodes, LastOpenNodes, Tick)</span> -&gt;</span></span><br><span class="line">    NewTick = close_node(Node, CurOpenNodes, LastOpenNodes, Tick),</span><br><span class="line">    close_nodes(Child, CurOpenNodes, LastOpenNodes, NewTick).</span><br><span class="line"><span class="function"><span class="title">close_node</span><span class="params">(#node&#123;id = Id&#125; = Node, CurOpenNodes, LastOpenNodes, #tick&#123;blackboard = Blackboard&#125; = Tick)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">case</span> lists:member(Id, LastOpenNodes) <span class="keyword">andalso</span></span><br><span class="line">         <span class="keyword">not</span> lists:member(Id, CurOpenNodes) <span class="keyword">andalso</span></span><br><span class="line">         get_key(&#123;is_open, Id&#125;, Blackboard, false) <span class="keyword">of</span></span><br><span class="line">        <span class="literal">true</span> -&gt;</span><br><span class="line">            <span class="comment">%%?DEBUG("close_node ~p", [Node]),</span></span><br><span class="line">            close_cb_(Node, Tick#tick&#123;blackboard = dict:store(&#123;is_open, Id&#125;, false, Blackboard)&#125;);</span><br><span class="line">        <span class="literal">false</span> -&gt;</span><br><span class="line">            Tick</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://github.com/behavior3/behavior3js" target="_blank" rel="noopener">behavior3</a></li>
<li><a href="https://github.com/wudeng/behavior_tree/" target="_blank" rel="noopener">参考源码</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Deng</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Deng</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>

<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
